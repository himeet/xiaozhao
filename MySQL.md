# 目录

[TOC]

# 内容

## 一. MySQL索引和引擎

### 1. 索引是什么？

索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据。

### 2. 索引具体采用的哪种数据结构呢？

常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树。

### 3. 为什么使用B+ 树索引？这和Hash索引比较起来有什么优缺点吗？

首先要知道Hash索引和B+树索引的底层实现原理:

hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.

**哈希索引的优点**：

- hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.

因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.

**哈希索引的缺点**：（索引排序、模糊查询、最左前缀匹配、回表查询、稳定性）

- hash索引**不支持使用索引进行排序**,原理同上.
- hash索引**不支持模糊查询以及多列索引的最左前缀匹配**。原理也是因为hash函数的不可预测.**AAAA**和**AAAAB**的索引没有相关性.
- **hash索引任何时候都避免不了回表查询数据**,而B+树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询.
- **hash索引虽然在等值查询上较快,但是不稳定，性能不可预测**。当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.

因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.

### 4. 什么是聚簇索引？

**聚簇索引&非聚簇索引**：在B+树的索引中，叶子节点可能存储了当前的key值（非聚簇索引，即将数据存储于索引分开存放，索引结构的叶子节点指向了数据的对应行），也可能存储了当前的key值以及整行的数据（聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据）。

**InnoDB中的聚簇索引**：在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引.

**为什么聚簇索引不用回表查询**：当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询。

### 5. 什么是覆盖索引？（TODO）



### 6. 非聚簇索引一定回表查询吗？

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。

举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行`select age from employee where age < 20`的查询时，在索引的叶子节点上,已经包含了age信息，不会再次进行回表查询。

### 7. 在建立索引的时候，都有哪些需要考虑的因素呢?

建立索引的时候一般要考虑到**字段的使用频率**，**经常作为条件进行查询的字段比较适合建立索引**。

如果需要建立联合索引的话，还需要考虑**联合索引中的顺序**。

此外也要考虑其他方面，比如防止过多的索引对表造成太大的压力，这些都和实际的表结构以及查询方式有关。

### 8. 联合索引是什么?为什么需要注意联合索引中的顺序?

**联合索引**：MySQL可以使用多个字段同时建立一个索引，叫做联合索引。

**原因**：在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

### 9. 如何查看创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?

MySQL提供了**explain命令来查看语句的执行计划**，MySQL在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。

可以通过其中和索引有关的信息来分析是否命中了索引，例如possilbe_key，key，key_len等字段，分别说明了此语句可能会使用的索引，实际使用的索引以及使用的索引长度。

### 10. 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?

- 使用不等于查询
- 列参与了数学运算或者函数
- 在字符串like时左边是通配符.类似于'%aaa'
- 当mysql分析全表扫描比使用索引快的时候不使用索引
- 当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引

以上5种情况均不使用索引。

### 11. InnoDB的特点

见13.InnoDB和MYISAM的对比

### 12. MYISAM的特点

见13.InnoDB和MYISAM的对比

### 13.  InnoDB和MYISAM对比

- InnoDB 支持事务（回滚），MyISAM 不支持事务

- InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败。

- InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

- InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。

- InnoDB 最小的锁粒度是行级锁，MyISAM 最小的锁粒度是表级锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。
- 对于自增长的字段，InnoDB中必须包含一个**只有该字段的索引**，而MyISAM中可以和其他字段一起建立联合索引。
- 清空表时，InnoDB一行一行删除，但是MyISAM会重建表。

### 14. 为什么MYISAM会比InnoDB的查询速度快？

- InnoDB在做SELECT的时候，要维护的东西比MYISAM引擎多很多

- 数据块，INNODB要缓存，MYISAM只缓存索引块， 这中间还有换进换出的减少

- InnoDB**寻址要映射到块，再到行**，MYISAM 记录的**直接是文件的OFFSET**， 定位比INNODB要快

- InnoDB**还需要维护MVCC一致**；虽然你的场景没有，但他还是需要去检查和维护（MVCC ( Multi-Version Concurrency Control )多版本并发控制）

### 15. MYISAM和InnoDB的适用场景？/MYISAM和InnoDB如何选择？

- MyISAM适合：(1)做很多count 的计算；(2)**插入不频繁，查询非常频繁**；(3)**没有事务**。

- InnoDB适合：(1)**可靠性**要求比较高，或者要求事务；(2)表**更新和查询都相当的频繁**，并且**行锁定的机会比较大**的情况。

---

## 二. MySQL事务

*视频链接：https://www.bilibili.com/video/BV1Lt4y1S7zF*

### 1. 什么是事务？

**事务**：事务就是一系列的数据库操作，要么全做，要么全不做，是不可分割的工作单位。

例如转账场景的收款和扣款。

### 2. 事务的ACID特性？

- 原子性（Atomicity）：要么都做，要么都不做。
- 一致性（Consistency）：事务执行的结果必须是从一个一致性状态转变为另一个一致性状态。
- 隔离性（Isolation）：并发执行的各个事务之间不能相互干扰。
- 持续性（Durability）：事务一旦提交，它对数据的改变就是永久的，接下来发生的事情不应该影响到该次的提交。

### 3. MySQL的四种隔离级别

MySQL四种隔离级别分别有可能产生的问题如下表所示：

| 隔离级别                           | 脏读 | 不可重复读 | 幻读 |
| ---------------------------------- | ---- | ---------- | ---- |
| Read Uncommitted（读取未提交内容） | ✅    | ✅          | ✅    |
| Read Committed（读取已提交内容）   | ❌    | ✅          | ✅    |
| Repeatable Read（可重复读）        | ❌    | ❌          | ✅    |
| Serializable（可串行化）           | ❌    | ❌          | ❌    |

#### 3.1 概述

SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

#### 3.2 脏读 & 不可重复读 & 幻读

- 脏读(Drity Read)：A事务执行过程中，B事务读取了A事务的修改。但是由于某些原因，A事务没有完成提交，发生了回滚操作，则B事务所读取的数据就会是不正确的。
- 不可重复读(Non-repeatable read)：B事务读取了两次同一条数据，在这两次的读取过程中A事务修改了数据，B事务的这两次读取出来的这一条数据本身发生了变化。
- 幻读(Phantom Read)：B事务读取了两次数据表，在这两次的读取过程中A事务添加或删除了几条数据，B事务的这两次读取出来的数据的**条数**不一样。

*ps：不可重复读强调读取的同一条数据的内容发生了变化，幻读强调了新增或者删除，即数据的条数发生了变化。*

*参考链接：https://blog.csdn.net/yuxin6866/article/details/52649048*

#### 3.3 Read uncommitted（读取未提交内容）

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

#### 3.3 Read committed（读取已提交内容）

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也即所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

#### 3.4 Repeatable Read（可重复读）

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

#### 3.5 Serializable（可串行化）

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。



### 4. xxx

### 5. xxx

### 6. xxx









