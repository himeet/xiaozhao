# 目录

[TOC]

# 内容

## 一. 设计模式的六大原则

- **开闭原则**：⼀个软件实体如类、模块和函数应该对修改封闭，对扩展开放。

- **单⼀职责原则**：⼀个类只做⼀件事，⼀个类应该只有⼀个引起它修改的原因。 

- **⾥⽒替换原则**：⼦类应该可以完全替换⽗类。也就是说在使⽤继承时，只扩展新功能，⽽不要破坏⽗类原 有的功能。 

- **依赖倒置原则**：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的⾼层，并保持稳定，程序的细节变化由低层的实现层来完成。 迪⽶特法则：⼜名「最少知道原则」，⼀个类不应知道⾃⼰操作的类的细节，换⾔之，只和朋友谈话，不 和朋友的朋友谈话。 

- **接⼝隔离原则**：客户端不应依赖它不需要的接⼝。如果⼀个接⼝在实现时，部分⽅法由于冗余被客户端空 实现，则应该将接⼝拆分，让实现类只需依赖⾃⼰需要的接⼝⽅法。

## 二. 5种构建型设计模式

设计模式一共有 23 种，下面先介绍5种**构建型模式**，分别是：

- 工厂方法模式（简单工厂模式可以认为是工厂方法模式的特例）
- 抽象工厂模式
- 单例模式
- 建造型模式
- 原型模式

### 1. 工厂模式

在平时编程中，构建对象最常⽤的⽅式是 new ⼀个对象，乍⼀看这种做法没什么不好，⽽实际上这也属于⼀种硬编码。每 new⼀个对象，相当于调⽤者多知道了⼀个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，⼯⼚模式便是⽤于封装对象的设计模式。

举个例⼦，直接 new 对象的⽅式相当于当我们需要⼀个苹果时，我们需要知道苹果的构造⽅法，需要⼀个梨⼦时，需要知道梨⼦的构造⽅法。更好的实现⽅式是有⼀个⽔果⼯⼚，我们告诉⼯⼚需要什么种类的⽔果，⽔果⼯⼚将我们需要的⽔果制造出来给我们就可以了。这样我们就⽆需知道苹果、梨⼦是怎么种出来的，只⽤和⽔果⼯⼚打交道即可。

### 1.1 简单工厂模式

**简单工厂模式**：简单工厂模式就是让一个工厂类承担构建所有对象的职责。调用者需要什么产品，让工厂生产出来即可。

**简单工厂模式的弊端**：

- 如果需要⽣产的产品过多，此模式会导致⼯⼚类过于庞⼤，承担过多的职责，变成超级类。当苹果⽣产过程需要修改时，要来修改此⼯⼚。梨⼦⽣产过程需要修改时，也要来修改此⼯⼚。也就是说这个类不⽌⼀个引起修改的原因。违背了单⼀职责原则。 
- 当要⽣产新的产品时，必须在⼯⼚类中添加新的分⽀。⽽开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，⽽不是修改既有的类，所以这就违背了开闭原则。

**简单工厂模式举例**：

以水果工厂、苹果、梨子举例。

水果工厂：

```java
public class FruitFactory {
  public Fruit create(String type) {
    switch (type) {
      case "苹果": return new Apple();
      case "梨子": return new Pear();
      default: throw new IllegalArgumentException("暂时没有这种水果");
    }
  }
}
```

调用者：

```java
public class User {
  private void eat() {
    FruitFactory fruitFactory = new FruitFactory();
    Fruit apple = fruitFactory.create("苹果");
    Fruit pear = fruitFactory.create("梨子");
    apple.eat();
    pear.eat();
  }
}
```

事实上，将构建过程封装的好处不仅可以降低耦合，如果某个产品构造⽅法相当复杂，使⽤⼯⼚模式可以⼤⼤减少代码重复。⽐如，如果⽣产⼀个苹果需要苹果种⼦、阳光、⽔分，将⼯⼚修改如下：

水果工厂（修改版）：

```java
public class FruitFactory {
  public Fruit create(String type) {
    switch(type) {
      case "苹果":
        AppleSeed appleSeed = new AppleSeed();
        Sunlight sunlight = new Sunlight();
        Water water = new Water();
        return new Apple(appleSeed, sunlight, water);
      case "梨子":
        return new Pear();
      default: 
        return IllegalArgumentException("暂时没有这种水果");
    }
  } 
}
```

调⽤者的代码则完全不需要变化，⽽且调⽤者不需要在每次需要苹果时，⾃⼰去构建苹果种⼦、阳光、⽔ 分以获得苹果。苹果的⽣产过程再复杂，也只是⼯⼚的事。这就是封装的好处，假如某天科学家发明了让苹果更⾹甜的肥料，要加⼊苹果的⽣产过程中的话，也只需要在⼯⼚中修改，调⽤者完全不⽤关⼼。

### 1.2 工厂方法模式

**工厂方法模式**：工厂方法模式规定每个产品都有一个专属工厂，比如苹果有专属的苹果工厂，梨子有专属的例子工厂。

**工厂方法模式的优势**：调⽤者⽆需知道苹果的⽣产细节，当⽣产过程需要修改时也⽆需更改调⽤端。同时，⼯⼚⽅法模式解决了简单⼯⼚模式的两个弊端。 当⽣产的产品种类越来越多时，⼯⼚类不会变成超级类。⼯⼚类会越来越多，保持灵活。不会越来越⼤、 变得臃肿。如果苹果的⽣产过程需要修改时，只需修改苹果⼯⼚。梨⼦的⽣产过程需要修改时，只需修改 梨⼦⼯⼚。符合单⼀职责原则。 当需要⽣产新的产品时，⽆需更改既有的⼯⼚，只需要添加新的⼯⼚即可。保持了⾯向对象的可扩展性， 符合开闭原则

**工厂方法模式举例**：

苹果工厂：

```java
public class AppleFactory {
	public Fruit create() {
    return new Apple();
  }
}
```

梨子工厂：

```java
public class PearFactory {
  public Fruit create() {
    return new Pear();
  }
}
```

调用者：

```java
public class User {
	private void eat() {
    AppleFactory appleFactory = new AppleFactory();
    Fruit apple = appleFactory.create();
    PearFactory pearFactory = new PearFactory();
    Fruit pear = pearFactory.create();
    apple.eat();
    pear.eat();
  }
}
```

有读者可能会开喷了，这样和直接 new 出苹果和梨⼦有什么区别？上⽂说⼯⼚是为了减少类与类之间的耦 合，让调⽤者尽可能少的和其他类打交道。⽤简单⼯⼚模式，我们只需要知道 FruitFactory，⽆需知道 Apple 、Pear 类，很容易看出耦合度降低了。但⽤⼯⼚⽅法模式，调⽤者虽然不需要和 Apple 、Pear 类打交道了，但却需要和 AppleFactory、PearFactory 类打交道。有⼏种⽔果就需要知道⼏个⼯⼚类，耦合度完全没有下降啊，甚⾄还增加了代码量！

 这位读者请先放下⼿中的⼤⼑，仔细想⼀想，⼯⼚模式的第⼆个优点在⼯⼚⽅法模式中还是存在的。当构建过程相当复杂时，⼯⼚将构建过程封装起来，调⽤者可以很⽅便的直接使⽤，同样以苹果⽣产为例：

苹果工厂类（修改版）：

```java
public class AppleFactory {
	public Fruit create() {
    AppleSeed appleSeed = new AppleSeed();
    Sunlight sunlight = new Sunlight();
    Water water = new Water();
    return new Apple(appleSeed, sunlight, water);
  }
}
```

调⽤者⽆需知道苹果的⽣产细节，当⽣产过程需要修改时也⽆需更改调⽤端。同时，⼯⼚⽅法模式解决了简单⼯⼚模式的两个弊端。 当⽣产的产品种类越来越多时，⼯⼚类不会变成超级类。⼯⼚类会越来越多，保持灵活。不会越来越⼤、 变得臃肿。如果苹果的⽣产过程需要修改时，只需修改苹果⼯⼚。梨⼦的⽣产过程需要修改时，只需修改 梨⼦⼯⼚。符合单⼀职责原则。 当需要⽣产新的产品时，⽆需更改既有的⼯⼚，只需要添加新的⼯⼚即可。保持了⾯向对象的可扩展性， 符合开闭原则。

### 1.3 抽象工厂模式

**抽象工厂模式**：对工厂方法模式进一步优化，提取出工厂接口。

**抽象工厂模式的优势**：

**抽象工厂模式举例**：

工厂接口：

```java
public interface IFactory {
  Fruit create();
}
```

苹果工厂：

```java
public class AppleFactory implements IFactory {
  @Override
	public Fruit create() {
    return new Apple();
  }
}
```



梨子工厂：

```java
public class PearFactory implements IFactory {
  @Override
  public Fruit create() {
    return new Pear();
  }
}
```

此时，调用者可以将AppleFactory和PearFactory统一作为IFactory对象使用。

调用者：

```java
public class User {
  private void eat() {
    IFactory appleFactory = new AppleFactory();
    Fruit apple = appleFactory.create();
    IFactory pearFactory = new PearFactory();
    Fruit pear = pearFactory.create();
    apple.eat();
    pear.eat();
  }
}
```

可以看到，我们在创建时指定了具体的⼯⼚类后，在使⽤时就⽆需再关⼼是哪个⼯⼚类，只需要将此⼯⼚ 当作抽象的 IFactory 接⼝使⽤即可。 由于调用者只和 IFactory 打交道了，调⽤的是接⼝中的⽅法，使⽤时根本不需要知道是在哪个具体⼯⼚中实现的这些⽅法，这就使得替换⼯⼚变得⾮常容易。

替换工厂举例：

吃苹果：

```java
public class User {
	private	void eat() {
    IFactory factory = new AppleFactory();
    Fruit fruit = factory.create();
    fruit.eat();
  }
}
```

将吃苹果替换成吃梨子，只需要更改一行代码即可：

```java
public class User {
	private void eat() {
    IFactory factory = new PearFactory();
    Fruit fruit = factory.create();
    fruit.eat();
  }
}
```

IFactory 中只有⼀个抽象⽅法时，或许还看不出抽象⼯⼚模式的威⼒。实际上抽象⼯⼚模式主要⽤ 于替换⼀系列⽅法。例如将程序中的 SQL Server 数据库整个替换为 Access 数据库，使⽤抽象⽅法模式的话，只需在 IFactory 接⼝中定义好增删改查四个⽅法，让 SQLFactory 和 AccessFactory 实现此接⼝，调⽤时直接使⽤ IFactory 中的抽象⽅法即可，调⽤者⽆需知道使⽤的什么数据库，我们就可以⾮常⽅便的整个替换程序的数据库，并且让调用者毫不知情。 抽象⼯⼚模式很好的发挥了开闭原则、依赖倒置原则，但缺点是抽象⼯⼚模式太重了，如果 IFactory 接⼝需要新增功能，则会影响到所有的具体⼯⼚类。使⽤抽象⼯⼚模式，替换具体⼯⼚时 只需更改⼀⾏代码，但要新增抽象⽅法则需要修改所有的具体⼯⼚类。所以抽象⼯⼚模式适⽤于增 加同类⼯⼚这样的横向扩展需求，不适合新增功能这样的纵向扩展。

---

### 2. 单例模式

**单例模式**：某个对象全局只需要一个实例时，就可以使用单例模式。单例模式有两种实现方式：饿汉式和懒汉式。

**单例模式的优势**：

- 能够避免对象重复创建，节约空间并提升效率
- 避免由于操作不同实例导致的逻辑错误

### 2.1 饿汉式

**饿汉式**：变量在声明时便初始化。

**优点**：（1）线程安全。（2）用户在打开页面时已加载完毕内容，用户体验良好。

**缺点**：即使这个单例不需要使⽤，它也会在类加载之后⽴即创建出来，占⽤⼀块内存，并增加类初始化时间。

```java
public class Singleton {
	private static Singleton instance = new Singleton();
  
  private Singleton() {
  }
  
  public static Singleton getInstance() {
    return instance;
  }
  
}
```

可以看到，我们将构造⽅法定义为 private，这就保证了其他类⽆法实例化此类，必须通过 getInstance ⽅法 才能获取到唯⼀的 instance 实例，⾮常直观。但饿汉式有⼀个**弊端**，那就是即使这个单例不需要使⽤，它也会在类加载之后⽴即创建出来，占⽤⼀块内存，并增加类初始化时间。就好⽐⼀个电⼯在修理灯泡时， 先把所有⼯具拿出来，不管是不是所有的⼯具都⽤得上。就像⼀个饥不择⻝的饿汉，所以称之为饿汉式。

### 2.2 懒汉式

**懒汉式**：先声明一个空变量，需要用时才初始化。

**优点**：解决了饿汉式的去缺点，按需加载，避免了内存浪费，减少了类初始化时间。

**缺点**：（1）线程不安全；（2）将程序加载时间从启动时延后到了运⾏时，虽然启动时间缩短了，但我们浏览⻚⾯时就会看到数据的 loading 过程，用户体验变差。

```java
public class Singleton {
	private static Singleton instance = null;
  
  private Singleton() {
  } 
  
  public static Singleton getInstance() {
    if (instance == null) {
      instance = new Singleton();
    }
    return instance;
  }
  
}
```

我们先声明了⼀个初始值为 null 的 instance 变量，当需要使⽤时判断此变量是否已被初始化，没有初始化的话才 new ⼀个实例出来。就好⽐电⼯在修理灯泡时，开始⽐较偷懒，什么⼯具都不拿，当发现需要使⽤螺丝⼑时，才把螺丝⼑拿出来。当需要⽤钳⼦时，再把钳⼦拿出来。就像⼀个不到万不得已不会⾏动的懒汉，所以称之为懒汉式。 懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。 上述代码的懒汉式单例乍⼀看没什么问题，但其实它是**线程不安全**的：如果有多个线程同⼀时间调⽤ getInstance ⽅法，instance 变量可能会被实例化多次。为了保证线程安全，**我们需要给判空过程加上锁**：

```java
public class Singleton {
	private static Singleton instance = null;
  
  private Singleton() {
  }
  
  public static Singleton getInstance() {
    synchronized (Singleton.class) {
       if (instance == null) {
       	instance = new Singleton();
    	}
    }
    return instance;
  }
}
```

这样就能保证多个线程调⽤ getInstance()时，⼀次最多只有⼀个线程能够执⾏判空并new出实例的操作， 所以 instance 只会实例化⼀次。但这样的写法仍然有问题，当多个线程调⽤ getInstance 时，每次都需要执⾏ synchronized 同步化⽅法，这样会严重影响程序的执⾏效率。所以更好的做法是在同步化之前，再加上⼀层检查：

```java
public class Singleton {
	private static Singleton instance = null;
  
  private Singleton() {
  }
  
  public static Singleton getInstance() {
    if (instance == null) {
    	synchronized (Singleton.class) {
        if (instance == null) {
          instance = new Singleton();
        }
    	}
    }
    return instance;
  }
}
```

这样增加⼀种检查⽅式后，如果instance已经被实例化，则不会执⾏同步化操作，⼤⼤提升了程序效率。 上⾯这种写法也就是我们平时较常⽤的**双检锁**⽅式实现的线程安全的单例模式。

但这样的懒汉式单例仍然有⼀个问题，JVM 底层为了优化程序运⾏效率，可能会对我们的代码进⾏指令重排序，在⼀些特殊情况下会导致单例模式线程不安全，为了防⽌这个问题，更进⼀步的优化是给 instance 变量加上**volatile关键字**（volatile关键字可以禁止指令重排序）。 

除了双检锁⽅式外，还有⼀种⽐较常⻅的**静态内部类⽅式**保证懒汉式单例的线程安全：

```java
public class Singleton {
  private static class SingletonHolder {
    public static Singleton instance = new Singleton();
  }
  
  private Singleton() {
  }
  
  public static Singleton getInstance() {
    return SingletonHolder.instance;
  }
}
```

虽然我们经常使⽤这种静态内部类的懒加载⽅式，但其中的原理不⼀定每个⼈都清楚。

接下来我们便来分析其原理，搞清楚两个问题： （1）静态内部类⽅式是怎么实现懒加载的； （2）静态内部类⽅式是怎么保证线程安全的。

- 静态内部类⽅式是怎么实现懒加载的 ：

 Java 类的加载过程包括：加载、验证、准备、解析、初始化。初始化阶段即执⾏类的 clinit ⽅法（clinit = class + initialize），包括为类的静态变量赋初始值和执⾏静态代码块中的内容。但不会⽴即加载内部类，内部类会在使⽤时才加载。所以当此 Singleton 类加载时，SingletonHolder 并不会被⽴即加载，所以不会像饿汉式那样占⽤内存。

 另外，Java 虚拟机规定，当访问⼀个类的静态字段时，如果该类尚未初始化，则⽴即初始化此类。当调⽤ Singleton 的 getInstance ⽅法时，由于其使⽤了 SingletonHolder 的静态变量 instance，所以这时才会去初 始化 SingletonHolder，在 SingletonHolder 中 new 出 Singleton 对象。这就实现了懒加载。 

- 静态内部类⽅式是怎么保证线程安全的：

 Java 虚拟机的设计是⾮常稳定的，早已经考虑到了多线程并发执⾏的情况。虚拟机在 加载类的 clinit ⽅法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化⼀个 类，⼀次也只有⼀个线程可以执⾏ clinit ⽅法，其他线程都需要阻塞等待，从⽽保证了线程安全。 

懒加载⽅式在平时⾮常常⻅，⽐如打开我们常⽤的美团、饿了么、⽀付宝 app，应⽤⾸⻚会⽴刻刷新出 来，但其他标签⻚在我们点击到时才会刷新。这样就减少了流量消耗，并缩短了程序启动时间。再⽐如游戏中的某些模块，当我们点击到时才会去下载资源，⽽不是事先将所有资源都先下载下来，这也属于懒加载⽅式，避免了内存浪费。

 但懒汉式的缺点就是将程序加载时间从启动时延后到了运⾏时，虽然启动时间缩短了，但我们浏览⻚⾯时就会看到数据的 loading 过程。如果⽤饿汉式将⻚⾯提前加载好，我们浏览时就会特别的顺畅，也不失为⼀个好的⽤户体验。⽐如我们常⽤的 QQ、微信 app，作为即时通讯的⼯具软件，它们会在启动时⽴即刷新所有的数据，保证⽤户看到最新最全的内容。著名的软件⼤师 Martin 在《代码整洁之道》⼀书中也说到：不提倡使⽤懒加载⽅式，因为程序应该将构建与使⽤分离，达到解耦。饿汉式在声明时直接初始化变量的⽅式也更直观易懂。所以在使⽤饿汉式还是懒汉式时，需要权衡利弊。 ⼀般的建议是：

**饿汉式&懒汉式的使用场景**：对于构建不复杂，加载完成后会⽴即使⽤的单例对象，推荐使⽤饿汉式。对于构建过程耗时较⻓，并不是所有使⽤此类都会⽤到的单例对象，推荐使⽤懒汉式。

---

## 3. 建造型模式

**建造型模式**：建造型模式⽤于创建过程稳定，但配置多变的对象。⽐如我们要制作⼀杯珍珠奶茶。它的制作过程是稳定的，除了必须要知道奶茶的种类和规格外，是否加珍珠和是否加冰是可选的。使⽤建造者模式表示如下：

**建造者模式优点**：使⽤建造者模式的好处是不⽤担⼼忘了指定某个配置，保证了构建过程是稳定的，在 OkHttp、Retrofit 等著名框架的源码中都使⽤到了建造者模式。

建造者模式：

```java
public class MilkTea {
  private final String type;  // 奶茶的类型
  private final String size;  // 奶茶的大中小杯
  private final boolean pearl;  // 是否加珍珠
  private final boolean ice;   // 是否加冰
  
  private MilkTea(Builder builder) {
    this.type = builder.type;
    this.size = builder.size;
    this.pearl = builder.pearl;
    this.ice = builder.ice;
  }
  
  public Stirng getType() {
    return type;
  }
  
  public String getSize() {
    return size;
  }
  
  public boolean isPearl() {
    return pearl;
  }
  
  public boolean isIce() {
    return ice;
  }
  
  public static class Builder {
    private final String type;
    private final String size = "中杯";
    private final boolean pearl = true;
    private final boolean ice = false;
    
    public Builder(String type) {
      this.type = type;
    }
    
    public Builder size(String size) {
      this.size = size;
      return this;
    }
    
    public Builder pearl(boolean pearl) {
      this.pearl = pearl;
      return this;
    }
    
    public Builder ice(boolean ice) {
      this.ice = ice;
      return this;
    }
    
    public MilkTea build() {
      return new MilkTea(this);
    }
  }
}
```

可以看到，我们将 MilkTea 的构造⽅法设置为私有的，所以外部不能通过 new 构建出 MilkTea 实例，只能通过 Builder 构建。对于必须配置的属性，通过 Builder 的构造⽅法传⼊，可选的属性通过 Builder 的链式调⽤⽅法传⼊，如果不配置，将使⽤默认配置，也就是中杯、加珍珠、不加冰。根据不同的配置可以制作出不 同的奶茶：

调用者：

```java
public class User {
	private void buyMilkTea() {
    MilkTea milkTea = new MilkTea.Builder("原味").build();
    show(milkTea);
    
    MilkTea chocolate = new MilkTea.Builder("巧克力味").ice(false).build();
    show(chocolate);
    
    MilkTea strawberry = new MilkTea.Builder("草莓味").size("大杯").pearl(false).ice(true).build();
    show(strawberry);
  }
}
```

---

## 4. 原型模式

**原型模式**：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。Java 中，Object 的 clone() 方法就属于原型模式。

举个例⼦，⽐如有⼀天，周杰伦到奶茶店点了⼀份不加冰的原味奶茶，你说我是周杰伦的忠实粉，我也要 ⼀份跟周杰伦⼀样的。⽤程序表示如下：

奶茶类：

```java
public class MilkTea {
	public String type;
  public boolean ice;
}
```

下单：

```java
private void order() {
  // 周杰伦点奶茶
	MilkTea milkTeaOfJay = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = false;
  
  // 粉丝要一份一样的
  // 这是错误的，因为复制操作传递的只是对象的地址
  MilkTea milkOfYou = milkTeaOfJay;
}
```

好像没什么问题，将周杰伦的奶茶直接赋值到你的奶茶上就⾏了，看起来我们并不需要 clone ⽅法。但是这样真的是复制了⼀份奶茶吗？ 当然不是，Java 的赋值只是传递地址。这样赋值之后，yourMilkTea 仍然指向的周杰伦的奶茶，并不会多⼀ 份⼀样的奶茶。 

那么我们要怎么做才能点⼀份⼀样的奶茶呢？将程序修改如下就可以了：

```java
private void order() {
  // 周杰伦点奶茶
	MilkTea milkTeaOfJay = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = false;
  
  // 粉丝要一份一样的
  MilkTea milkTeaOfYou = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = false;
}
```

只有这样，yourMilkTea 才是 new 出来的⼀份全新的奶茶。

我们设想⼀下，如果有⼀千个粉丝都需要点和周 杰伦⼀样的奶茶的话，按照现在的写法就需要 new ⼀千次，并为每⼀个新的对象赋值⼀千次，造成⼤量的重复。 

更糟糕的是，如果周杰伦临时决定加个冰，那么粉丝们的奶茶配置也要跟着修改：

```java
private void order() {
  // 周杰伦点奶茶
	MilkTea milkTeaOfJay = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = true;
  
  // 粉丝要一份一样的
  MilkTea milkTeaOfYou = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = true;
  
  // 1000个粉丝都要改为 加冰 ice=true
  ...
}
```

⼤批量的修改⽆疑是⾮常丑陋的做法，这就是我们需要 clone ⽅法的理由！

 运⽤原型模式，在 MilkTea 中新增 clone ⽅法：

奶茶类（修改版）：

```java
public class MilkTea {
	public String type;
  public boolean ice;
  
  public MilkTea clone() {
    MilkTea milkTea = new MilkTea();
    milkTea.type = this.type;
    milkTea.ice = this.ice;
    return milkTea;
  }
}
```

下单（修改版）：

```java
private void order() {
	// 周杰伦点奶茶
	MilkTea milkTeaOfJay = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = true;
  
  // 粉丝要一份一样的
  MilkTea milkTeaOfYou = milkTeaOfJay.clone();
  
  // 1000个粉丝也要一份一样的，都只需要调用 milkTeaOfJay.clone() 即可
  ...
}
```

这就是原型模式，Java 中有⼀个语法糖，让我们并不需要⼿写 clone ⽅法。这个语法糖就是Cloneable接⼝，我们只要让需要拷⻉的类实现此接⼝即可：

```java
public class MilkTea implements Cloneable {
  public String type;
  private boolean ice;
  
  @NonNull
  @Override
  protected MilkTea clone() throws CloneNotSupportedException {
    return (MilkTea) super.clone();
  }
}
```

值得注意的是，Java⾃带的 clone ⽅法是浅拷⻉的。也就是说调⽤此对象的 clone ⽅法，只有基本类型的 参数会被拷⻉⼀份，⾮基本类型的对象不会被拷⻉⼀份，⽽是继续使⽤传递引⽤的⽅式。如果需要实现深拷⻉，必须要⾃⼰⼿动修改 clone ⽅法才 ⾏。



## 三. 7种结构型模式

**结构型模式**：结构型模式是用来设计程序的结构的。结构型模式就像搭积木，将不同的类结合在一起形成契合的结构。

下面介绍7种结构型模式：

- 适配器模式
- 桥接模式
- 组合模式
- 装饰模式
- 外观模式
- 享元模式
- 代理模式

## 1. 适配器模式

**适配器模式**：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。（可以类比目前的手机适配器）。适配器模式适⽤于**有相关性但不兼容的结构**，源接⼝通过⼀个中间件转换后才可以适⽤于⽬标接⼝，这个 转换过程就是适配，这个中间件就称之为适配器。

使用 家用电源220V电压 和 手机的USB充电线需要5V电压 来举例：

家用电源的220V电压：

```java
public class HomeBattery {
	public int supply() {
    return 220;  // 家用电源提供220V的输出电压
  }
}
```

手机的USB数据线只接受5V电压：

```java
public class USBLine {
  public void charge(int volt) {
    // 如果电压不是5V，抛出异常
    if (volt != 5) {
      throw new IllegalArgumentException("只能接收5V电压");
    }
    // 如果电压是5V，正常充电
    System.out.println("正常充电");
  }
}
```

在适配之前，使用家用电源直接给手机充电：

调用者：

```java
public class User {
  public void chargeForPhone() {
    // 家庭电源提供220V电压
    HomeBattery homeBattery = new HomeBattery();
    int homeVolt = homeBattery.supply();  
    
    // 使用家庭电源直接给手机充电
    USBLine usbLine = new USBLine();
    usbLine.charge(homeVolt);  // 程序运行后会抛出异常：java.lang.IllegalArgumentException: 只能接收 5V 电压
  }
}
```

这时，我们加入电源适配器：

```java
public class Adapter {
	public int convert(int homeVolt) {
    int chargeVolt = homeVolt - 215;  // 使用电阻电容等器件将电压降至5V
    return chargeVolt;
  }
}
```

加入适配器之后，使用家用电源经过适配器的电压转换再给手机充电：

```java
public class User {
	public void chargeForPhone() {
    // 家庭电源
    HomeBattery homeBattery = new HomeBattery();
    int homeVolt = homeBattery.supply();
    
    // 家庭电源经过适配器进行电压转换
    Adapter adapter = new Adapter();
    int chargeVolt =  adapter.convert(homeVolt);
    
    // 使用适配器转换后的电压给手机充电
    USBLine usbLine = new USBLine();
    usbLine.charge(chargeVolt);  // 此时可以正常充电
  }
}
```

适配器模式并不推荐多⽤。因为未⾬绸缪好过亡⽺补牢，如果事先能预防接⼝不同的问题，不匹配问题就不会发⽣，只有遇到源接⼝⽆法改变时，才应该考虑使⽤适配器。⽐如现代的电源插⼝中很多已经增加了专⻔的充电接⼝，让我们不需要再使⽤适配器转换接⼝，这⼜是社会的⼀个进步。

## 2. 桥接模式

**桥接模式**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。



## 3. 组合模式

## 4. 装饰模式

## 5. 外观模式

## 6. 享元模式

## 7. 代理模式



