# 目录

[TOC]

# 内容

## 一. 设计模式的六大原则

- **开闭原则**：⼀个软件实体如类、模块和函数应该对修改封闭，对扩展开放。

- **单⼀职责原则**：⼀个类只做⼀件事，⼀个类应该只有⼀个引起它修改的原因。 

- **⾥⽒替换原则**：⼦类应该可以完全替换⽗类。也就是说在使⽤继承时，只扩展新功能，⽽不要破坏⽗类原 有的功能。 

- **依赖倒置原则**：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的⾼层，并保持稳定，程序的细节变化由低层的实现层来完成。 迪⽶特法则：⼜名「最少知道原则」，⼀个类不应知道⾃⼰操作的类的细节，换⾔之，只和朋友谈话，不 和朋友的朋友谈话。 

- **接⼝隔离原则**：客户端不应依赖它不需要的接⼝。如果⼀个接⼝在实现时，部分⽅法由于冗余被客户端空 实现，则应该将接⼝拆分，让实现类只需依赖⾃⼰需要的接⼝⽅法。

## 二. 5种构建型设计模式

设计模式一共有 23 种，下面先介绍5种**构建型模式**，分别是：

- 工厂方法模式（简单工厂模式可以认为是工厂方法模式的特例）
- 抽象工厂模式
- 单例模式
- 建造型模式
- 原型模式

### 1. 工厂模式

在平时编程中，构建对象最常⽤的⽅式是 new ⼀个对象，乍⼀看这种做法没什么不好，⽽实际上这也属于⼀种硬编码。每 new⼀个对象，相当于调⽤者多知道了⼀个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，⼯⼚模式便是⽤于封装对象的设计模式。

举个例⼦，直接 new 对象的⽅式相当于当我们需要⼀个苹果时，我们需要知道苹果的构造⽅法，需要⼀个梨⼦时，需要知道梨⼦的构造⽅法。更好的实现⽅式是有⼀个⽔果⼯⼚，我们告诉⼯⼚需要什么种类的⽔果，⽔果⼯⼚将我们需要的⽔果制造出来给我们就可以了。这样我们就⽆需知道苹果、梨⼦是怎么种出来的，只⽤和⽔果⼯⼚打交道即可。

### 1.1 简单工厂模式

**简单工厂模式**：简单工厂模式就是让一个工厂类承担构建所有对象的职责。调用者需要什么产品，让工厂生产出来即可。

**简单工厂模式的弊端**：

- 如果需要⽣产的产品过多，此模式会导致⼯⼚类过于庞⼤，承担过多的职责，变成超级类。当苹果⽣产过程需要修改时，要来修改此⼯⼚。梨⼦⽣产过程需要修改时，也要来修改此⼯⼚。也就是说这个类不⽌⼀个引起修改的原因。违背了单⼀职责原则。 
- 当要⽣产新的产品时，必须在⼯⼚类中添加新的分⽀。⽽开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，⽽不是修改既有的类，所以这就违背了开闭原则。

**简单工厂模式举例**：

以水果工厂、苹果、梨子举例。

水果工厂：

```java
public class FruitFactory {
  public Fruit create(String type) {
    switch (type) {
      case "苹果": return new Apple();
      case "梨子": return new Pear();
      default: throw new IllegalArgumentException("暂时没有这种水果");
    }
  }
}
```

调用者：

```java
public class User {
  private void eat() {
    FruitFactory fruitFactory = new FruitFactory();
    Fruit apple = fruitFactory.create("苹果");
    Fruit pear = fruitFactory.create("梨子");
    apple.eat();
    pear.eat();
  }
}
```

事实上，将构建过程封装的好处不仅可以降低耦合，如果某个产品构造⽅法相当复杂，使⽤⼯⼚模式可以⼤⼤减少代码重复。⽐如，如果⽣产⼀个苹果需要苹果种⼦、阳光、⽔分，将⼯⼚修改如下：

水果工厂（修改版）：

```java
public class FruitFactory {
  public Fruit create(String type) {
    switch(type) {
      case "苹果":
        AppleSeed appleSeed = new AppleSeed();
        Sunlight sunlight = new Sunlight();
        Water water = new Water();
        return new Apple(appleSeed, sunlight, water);
      case "梨子":
        return new Pear();
      default: 
        return IllegalArgumentException("暂时没有这种水果");
    }
  } 
}
```

调⽤者的代码则完全不需要变化，⽽且调⽤者不需要在每次需要苹果时，⾃⼰去构建苹果种⼦、阳光、⽔ 分以获得苹果。苹果的⽣产过程再复杂，也只是⼯⼚的事。这就是封装的好处，假如某天科学家发明了让苹果更⾹甜的肥料，要加⼊苹果的⽣产过程中的话，也只需要在⼯⼚中修改，调⽤者完全不⽤关⼼。

### 1.2 工厂方法模式

**工厂方法模式**：工厂方法模式规定每个产品都有一个专属工厂，比如苹果有专属的苹果工厂，梨子有专属的例子工厂。

**工厂方法模式的优势**：调⽤者⽆需知道苹果的⽣产细节，当⽣产过程需要修改时也⽆需更改调⽤端。同时，⼯⼚⽅法模式解决了简单⼯⼚模式的两个弊端。 当⽣产的产品种类越来越多时，⼯⼚类不会变成超级类。⼯⼚类会越来越多，保持灵活。不会越来越⼤、 变得臃肿。如果苹果的⽣产过程需要修改时，只需修改苹果⼯⼚。梨⼦的⽣产过程需要修改时，只需修改 梨⼦⼯⼚。符合单⼀职责原则。 当需要⽣产新的产品时，⽆需更改既有的⼯⼚，只需要添加新的⼯⼚即可。保持了⾯向对象的可扩展性， 符合开闭原则

**工厂方法模式举例**：

苹果工厂：

```java
public class AppleFactory {
	public Fruit create() {
    return new Apple();
  }
}
```

梨子工厂：

```java
public class PearFactory {
  public Fruit create() {
    return new Pear();
  }
}
```

调用者：

```java
public class User {
	private void eat() {
    AppleFactory appleFactory = new AppleFactory();
    Fruit apple = appleFactory.create();
    PearFactory pearFactory = new PearFactory();
    Fruit pear = pearFactory.create();
    apple.eat();
    pear.eat();
  }
}
```

有读者可能会开喷了，这样和直接 new 出苹果和梨⼦有什么区别？上⽂说⼯⼚是为了减少类与类之间的耦 合，让调⽤者尽可能少的和其他类打交道。⽤简单⼯⼚模式，我们只需要知道 FruitFactory，⽆需知道 Apple 、Pear 类，很容易看出耦合度降低了。但⽤⼯⼚⽅法模式，调⽤者虽然不需要和 Apple 、Pear 类打交道了，但却需要和 AppleFactory、PearFactory 类打交道。有⼏种⽔果就需要知道⼏个⼯⼚类，耦合度完全没有下降啊，甚⾄还增加了代码量！

 这位读者请先放下⼿中的⼤⼑，仔细想⼀想，⼯⼚模式的第⼆个优点在⼯⼚⽅法模式中还是存在的。当构建过程相当复杂时，⼯⼚将构建过程封装起来，调⽤者可以很⽅便的直接使⽤，同样以苹果⽣产为例：

苹果工厂类（修改版）：

```java
public class AppleFactory {
	public Fruit create() {
    AppleSeed appleSeed = new AppleSeed();
    Sunlight sunlight = new Sunlight();
    Water water = new Water();
    return new Apple(appleSeed, sunlight, water);
  }
}
```

调⽤者⽆需知道苹果的⽣产细节，当⽣产过程需要修改时也⽆需更改调⽤端。同时，⼯⼚⽅法模式解决了简单⼯⼚模式的两个弊端。 当⽣产的产品种类越来越多时，⼯⼚类不会变成超级类。⼯⼚类会越来越多，保持灵活。不会越来越⼤、 变得臃肿。如果苹果的⽣产过程需要修改时，只需修改苹果⼯⼚。梨⼦的⽣产过程需要修改时，只需修改 梨⼦⼯⼚。符合单⼀职责原则。 当需要⽣产新的产品时，⽆需更改既有的⼯⼚，只需要添加新的⼯⼚即可。保持了⾯向对象的可扩展性， 符合开闭原则。

### 1.3 抽象工厂模式

**抽象工厂模式**：对工厂方法模式进一步优化，提取出工厂接口。

**抽象工厂模式的优势**：

**抽象工厂模式举例**：

工厂接口：

```java
public interface IFactory {
  Fruit create();
}
```

苹果工厂：

```java
public class AppleFactory implements IFactory {
  @Override
	public Fruit create() {
    return new Apple();
  }
}
```



梨子工厂：

```java
public class PearFactory implements IFactory {
  @Override
  public Fruit create() {
    return new Pear();
  }
}
```

此时，调用者可以将AppleFactory和PearFactory统一作为IFactory对象使用。

调用者：

```java
public class User {
  private void eat() {
    IFactory appleFactory = new AppleFactory();
    Fruit apple = appleFactory.create();
    IFactory pearFactory = new PearFactory();
    Fruit pear = pearFactory.create();
    apple.eat();
    pear.eat();
  }
}
```

可以看到，我们在创建时指定了具体的⼯⼚类后，在使⽤时就⽆需再关⼼是哪个⼯⼚类，只需要将此⼯⼚ 当作抽象的 IFactory 接⼝使⽤即可。 由于调用者只和 IFactory 打交道了，调⽤的是接⼝中的⽅法，使⽤时根本不需要知道是在哪个具体⼯⼚中实现的这些⽅法，这就使得替换⼯⼚变得⾮常容易。

替换工厂举例：

吃苹果：

```java
public class User {
	private	void eat() {
    IFactory factory = new AppleFactory();
    Fruit fruit = factory.create();
    fruit.eat();
  }
}
```

将吃苹果替换成吃梨子，只需要更改一行代码即可：

```java
public class User {
	private void eat() {
    IFactory factory = new PearFactory();
    Fruit fruit = factory.create();
    fruit.eat();
  }
}
```

IFactory 中只有⼀个抽象⽅法时，或许还看不出抽象⼯⼚模式的威⼒。实际上抽象⼯⼚模式主要⽤ 于替换⼀系列⽅法。例如将程序中的 SQL Server 数据库整个替换为 Access 数据库，使⽤抽象⽅法模式的话，只需在 IFactory 接⼝中定义好增删改查四个⽅法，让 SQLFactory 和 AccessFactory 实现此接⼝，调⽤时直接使⽤ IFactory 中的抽象⽅法即可，调⽤者⽆需知道使⽤的什么数据库，我们就可以⾮常⽅便的整个替换程序的数据库，并且让调用者毫不知情。 抽象⼯⼚模式很好的发挥了开闭原则、依赖倒置原则，但缺点是抽象⼯⼚模式太重了，如果 IFactory 接⼝需要新增功能，则会影响到所有的具体⼯⼚类。使⽤抽象⼯⼚模式，替换具体⼯⼚时 只需更改⼀⾏代码，但要新增抽象⽅法则需要修改所有的具体⼯⼚类。所以抽象⼯⼚模式适⽤于增 加同类⼯⼚这样的横向扩展需求，不适合新增功能这样的纵向扩展。

---

### 2. 单例模式

**单例模式**：某个对象全局只需要一个实例时，就可以使用单例模式。单例模式有两种实现方式：饿汉式和懒汉式。

**单例模式的优势**：

- 能够避免对象重复创建，节约空间并提升效率
- 避免由于操作不同实例导致的逻辑错误

### 2.1 饿汉式

**饿汉式**：变量在声明时便初始化。

**优点**：（1）线程安全。（2）用户在打开页面时已加载完毕内容，用户体验良好。

**缺点**：即使这个单例不需要使⽤，它也会在类加载之后⽴即创建出来，占⽤⼀块内存，并增加类初始化时间。

```java
public class Singleton {
	private static Singleton instance = new Singleton();
  
  private Singleton() {
  }
  
  public static Singleton getInstance() {
    return instance;
  }
  
}
```

可以看到，我们将构造⽅法定义为 private，这就保证了其他类⽆法实例化此类，必须通过 getInstance ⽅法 才能获取到唯⼀的 instance 实例，⾮常直观。但饿汉式有⼀个**弊端**，那就是即使这个单例不需要使⽤，它也会在类加载之后⽴即创建出来，占⽤⼀块内存，并增加类初始化时间。就好⽐⼀个电⼯在修理灯泡时， 先把所有⼯具拿出来，不管是不是所有的⼯具都⽤得上。就像⼀个饥不择⻝的饿汉，所以称之为饿汉式。

### 2.2 懒汉式

**懒汉式**：先声明一个空变量，需要用时才初始化。

**优点**：解决了饿汉式的去缺点，按需加载，避免了内存浪费，减少了类初始化时间。

**缺点**：（1）线程不安全；（2）将程序加载时间从启动时延后到了运⾏时，虽然启动时间缩短了，但我们浏览⻚⾯时就会看到数据的 loading 过程，用户体验变差。

```java
public class Singleton {
	private static Singleton instance = null;
  
  private Singleton() {
  } 
  
  public static Singleton getInstance() {
    if (instance == null) {
      instance = new Singleton();
    }
    return instance;
  }
  
}
```

我们先声明了⼀个初始值为 null 的 instance 变量，当需要使⽤时判断此变量是否已被初始化，没有初始化的话才 new ⼀个实例出来。就好⽐电⼯在修理灯泡时，开始⽐较偷懒，什么⼯具都不拿，当发现需要使⽤螺丝⼑时，才把螺丝⼑拿出来。当需要⽤钳⼦时，再把钳⼦拿出来。就像⼀个不到万不得已不会⾏动的懒汉，所以称之为懒汉式。 懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。 上述代码的懒汉式单例乍⼀看没什么问题，但其实它是**线程不安全**的：如果有多个线程同⼀时间调⽤ getInstance ⽅法，instance 变量可能会被实例化多次。为了保证线程安全，**我们需要给判空过程加上锁**：

```java
public class Singleton {
	private static Singleton instance = null;
  
  private Singleton() {
  }
  
  public static Singleton getInstance() {
    synchronized (Singleton.class) {
       if (instance == null) {
       	instance = new Singleton();
    	}
    }
    return instance;
  }
}
```

这样就能保证多个线程调⽤ getInstance()时，⼀次最多只有⼀个线程能够执⾏判空并new出实例的操作， 所以 instance 只会实例化⼀次。但这样的写法仍然有问题，当多个线程调⽤ getInstance 时，每次都需要执⾏ synchronized 同步化⽅法，这样会严重影响程序的执⾏效率。所以更好的做法是在同步化之前，再加上⼀层检查：

```java
public class Singleton {
	private static Singleton instance = null;
  
  private Singleton() {
  }
  
  public static Singleton getInstance() {
    if (instance == null) {
    	synchronized (Singleton.class) {
        if (instance == null) {
          instance = new Singleton();
        }
    	}
    }
    return instance;
  }
}
```

这样增加⼀种检查⽅式后，如果instance已经被实例化，则不会执⾏同步化操作，⼤⼤提升了程序效率。 上⾯这种写法也就是我们平时较常⽤的**双检锁**⽅式实现的线程安全的单例模式。

但这样的懒汉式单例仍然有⼀个问题，JVM 底层为了优化程序运⾏效率，可能会对我们的代码进⾏指令重排序，在⼀些特殊情况下会导致单例模式线程不安全，为了防⽌这个问题，更进⼀步的优化是给 instance 变量加上**volatile关键字**（volatile关键字可以禁止指令重排序）。 

除了双检锁⽅式外，还有⼀种⽐较常⻅的**静态内部类⽅式**保证懒汉式单例的线程安全：

```java
public class Singleton {
  private static class SingletonHolder {
    public static Singleton instance = new Singleton();
  }
  
  private Singleton() {
  }
  
  public static Singleton getInstance() {
    return SingletonHolder.instance;
  }
}
```

虽然我们经常使⽤这种静态内部类的懒加载⽅式，但其中的原理不⼀定每个⼈都清楚。

接下来我们便来分析其原理，搞清楚两个问题： （1）静态内部类⽅式是怎么实现懒加载的； （2）静态内部类⽅式是怎么保证线程安全的。

- 静态内部类⽅式是怎么实现懒加载的 ：

 Java 类的加载过程包括：加载、验证、准备、解析、初始化。初始化阶段即执⾏类的 clinit ⽅法（clinit = class + initialize），包括为类的静态变量赋初始值和执⾏静态代码块中的内容。但不会⽴即加载内部类，内部类会在使⽤时才加载。所以当此 Singleton 类加载时，SingletonHolder 并不会被⽴即加载，所以不会像饿汉式那样占⽤内存。

 另外，Java 虚拟机规定，当访问⼀个类的静态字段时，如果该类尚未初始化，则⽴即初始化此类。当调⽤ Singleton 的 getInstance ⽅法时，由于其使⽤了 SingletonHolder 的静态变量 instance，所以这时才会去初 始化 SingletonHolder，在 SingletonHolder 中 new 出 Singleton 对象。这就实现了懒加载。 

- 静态内部类⽅式是怎么保证线程安全的：

 Java 虚拟机的设计是⾮常稳定的，早已经考虑到了多线程并发执⾏的情况。虚拟机在 加载类的 clinit ⽅法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化⼀个 类，⼀次也只有⼀个线程可以执⾏ clinit ⽅法，其他线程都需要阻塞等待，从⽽保证了线程安全。 

懒加载⽅式在平时⾮常常⻅，⽐如打开我们常⽤的美团、饿了么、⽀付宝 app，应⽤⾸⻚会⽴刻刷新出 来，但其他标签⻚在我们点击到时才会刷新。这样就减少了流量消耗，并缩短了程序启动时间。再⽐如游戏中的某些模块，当我们点击到时才会去下载资源，⽽不是事先将所有资源都先下载下来，这也属于懒加载⽅式，避免了内存浪费。

 但懒汉式的缺点就是将程序加载时间从启动时延后到了运⾏时，虽然启动时间缩短了，但我们浏览⻚⾯时就会看到数据的 loading 过程。如果⽤饿汉式将⻚⾯提前加载好，我们浏览时就会特别的顺畅，也不失为⼀个好的⽤户体验。⽐如我们常⽤的 QQ、微信 app，作为即时通讯的⼯具软件，它们会在启动时⽴即刷新所有的数据，保证⽤户看到最新最全的内容。著名的软件⼤师 Martin 在《代码整洁之道》⼀书中也说到：不提倡使⽤懒加载⽅式，因为程序应该将构建与使⽤分离，达到解耦。饿汉式在声明时直接初始化变量的⽅式也更直观易懂。所以在使⽤饿汉式还是懒汉式时，需要权衡利弊。 ⼀般的建议是：

**饿汉式&懒汉式的使用场景**：对于构建不复杂，加载完成后会⽴即使⽤的单例对象，推荐使⽤饿汉式。对于构建过程耗时较⻓，并不是所有使⽤此类都会⽤到的单例对象，推荐使⽤懒汉式。

---

## 3. 建造型模式

**建造型模式**：建造型模式⽤于创建过程稳定，但配置多变的对象。⽐如我们要制作⼀杯珍珠奶茶。它的制作过程是稳定的，除了必须要知道奶茶的种类和规格外，是否加珍珠和是否加冰是可选的。使⽤建造者模式表示如下：

**建造者模式优点**：使⽤建造者模式的好处是不⽤担⼼忘了指定某个配置，保证了构建过程是稳定的，在 OkHttp、Retrofit 等著名框架的源码中都使⽤到了建造者模式。

建造者模式：

```java
public class MilkTea {
  private final String type;  // 奶茶的类型
  private final String size;  // 奶茶的大中小杯
  private final boolean pearl;  // 是否加珍珠
  private final boolean ice;   // 是否加冰
  
  private MilkTea(Builder builder) {
    this.type = builder.type;
    this.size = builder.size;
    this.pearl = builder.pearl;
    this.ice = builder.ice;
  }
  
  public Stirng getType() {
    return type;
  }
  
  public String getSize() {
    return size;
  }
  
  public boolean isPearl() {
    return pearl;
  }
  
  public boolean isIce() {
    return ice;
  }
  
  public static class Builder {
    private final String type;
    private final String size = "中杯";
    private final boolean pearl = true;
    private final boolean ice = false;
    
    public Builder(String type) {
      this.type = type;
    }
    
    public Builder size(String size) {
      this.size = size;
      return this;
    }
    
    public Builder pearl(boolean pearl) {
      this.pearl = pearl;
      return this;
    }
    
    public Builder ice(boolean ice) {
      this.ice = ice;
      return this;
    }
    
    public MilkTea build() {
      return new MilkTea(this);
    }
  }
}
```

可以看到，我们将 MilkTea 的构造⽅法设置为私有的，所以外部不能通过 new 构建出 MilkTea 实例，只能通过 Builder 构建。对于必须配置的属性，通过 Builder 的构造⽅法传⼊，可选的属性通过 Builder 的链式调⽤⽅法传⼊，如果不配置，将使⽤默认配置，也就是中杯、加珍珠、不加冰。根据不同的配置可以制作出不 同的奶茶：

调用者：

```java
public class User {
	private void buyMilkTea() {
    MilkTea milkTea = new MilkTea.Builder("原味").build();
    show(milkTea);
    
    MilkTea chocolate = new MilkTea.Builder("巧克力味").ice(false).build();
    show(chocolate);
    
    MilkTea strawberry = new MilkTea.Builder("草莓味").size("大杯").pearl(false).ice(true).build();
    show(strawberry);
  }
}
```

---

## 4. 原型模式

**原型模式**：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。Java 中，Object 的 clone() 方法就属于原型模式。

举个例⼦，⽐如有⼀天，周杰伦到奶茶店点了⼀份不加冰的原味奶茶，你说我是周杰伦的忠实粉，我也要 ⼀份跟周杰伦⼀样的。⽤程序表示如下：

奶茶类：

```java
public class MilkTea {
	public String type;
  public boolean ice;
}
```

下单：

```java
private void order() {
  // 周杰伦点奶茶
	MilkTea milkTeaOfJay = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = false;
  
  // 粉丝要一份一样的
  // 这是错误的，因为复制操作传递的只是对象的地址
  MilkTea milkOfYou = milkTeaOfJay;
}
```

好像没什么问题，将周杰伦的奶茶直接赋值到你的奶茶上就⾏了，看起来我们并不需要 clone ⽅法。但是这样真的是复制了⼀份奶茶吗？ 当然不是，Java 的赋值只是传递地址。这样赋值之后，yourMilkTea 仍然指向的周杰伦的奶茶，并不会多⼀ 份⼀样的奶茶。 

那么我们要怎么做才能点⼀份⼀样的奶茶呢？将程序修改如下就可以了：

```java
private void order() {
  // 周杰伦点奶茶
	MilkTea milkTeaOfJay = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = false;
  
  // 粉丝要一份一样的
  MilkTea milkTeaOfYou = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = false;
}
```

只有这样，yourMilkTea 才是 new 出来的⼀份全新的奶茶。

我们设想⼀下，如果有⼀千个粉丝都需要点和周 杰伦⼀样的奶茶的话，按照现在的写法就需要 new ⼀千次，并为每⼀个新的对象赋值⼀千次，造成⼤量的重复。 

更糟糕的是，如果周杰伦临时决定加个冰，那么粉丝们的奶茶配置也要跟着修改：

```java
private void order() {
  // 周杰伦点奶茶
	MilkTea milkTeaOfJay = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = true;
  
  // 粉丝要一份一样的
  MilkTea milkTeaOfYou = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = true;
  
  // 1000个粉丝都要改为 加冰 ice=true
  ...
}
```

⼤批量的修改⽆疑是⾮常丑陋的做法，这就是我们需要 clone ⽅法的理由！

 运⽤原型模式，在 MilkTea 中新增 clone ⽅法：

奶茶类（修改版）：

```java
public class MilkTea {
	public String type;
  public boolean ice;
  
  public MilkTea clone() {
    MilkTea milkTea = new MilkTea();
    milkTea.type = this.type;
    milkTea.ice = this.ice;
    return milkTea;
  }
}
```

下单（修改版）：

```java
private void order() {
	// 周杰伦点奶茶
	MilkTea milkTeaOfJay = new MilkTea();
  milkTeaOfJay.type = "原味";
  milkTeaOfJay.ice = true;
  
  // 粉丝要一份一样的
  MilkTea milkTeaOfYou = milkTeaOfJay.clone();
  
  // 1000个粉丝也要一份一样的，都只需要调用 milkTeaOfJay.clone() 即可
  ...
}
```

这就是原型模式，Java 中有⼀个语法糖，让我们并不需要⼿写 clone ⽅法。这个语法糖就是Cloneable接⼝，我们只要让需要拷⻉的类实现此接⼝即可：

```java
public class MilkTea implements Cloneable {
  public String type;
  private boolean ice;
  
  @NonNull
  @Override
  protected MilkTea clone() throws CloneNotSupportedException {
    return (MilkTea) super.clone();
  }
}
```

值得注意的是，Java⾃带的 clone ⽅法是浅拷⻉的。也就是说调⽤此对象的 clone ⽅法，只有基本类型的 参数会被拷⻉⼀份，⾮基本类型的对象不会被拷⻉⼀份，⽽是继续使⽤传递引⽤的⽅式。如果需要实现深拷⻉，必须要⾃⼰⼿动修改 clone ⽅法才 ⾏。



## 三. 7种结构型模式

**结构型模式**：结构型模式是用来设计程序的结构的。结构型模式就像搭积木，将不同的类结合在一起形成契合的结构。

下面介绍7种结构型模式：

- 适配器模式
- 桥接模式
- 组合模式
- 装饰模式
- 外观模式
- 享元模式
- 代理模式

## 1. 适配器模式

**适配器模式**：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。（可以类比目前的手机适配器）。适配器模式适⽤于**有相关性但不兼容的结构**，源接⼝通过⼀个中间件转换后才可以适⽤于⽬标接⼝，这个 转换过程就是适配，这个中间件就称之为适配器。

使用 家用电源220V电压 和 手机的USB充电线需要5V电压 来举例：

家用电源的220V电压：

```java
public class HomeBattery {
	public int supply() {
    return 220;  // 家用电源提供220V的输出电压
  }
}
```

手机的USB数据线只接受5V电压：

```java
public class USBLine {
  public void charge(int volt) {
    // 如果电压不是5V，抛出异常
    if (volt != 5) {
      throw new IllegalArgumentException("只能接收5V电压");
    }
    // 如果电压是5V，正常充电
    System.out.println("正常充电");
  }
}
```

在适配之前，使用家用电源直接给手机充电：

调用者：

```java
public class User {
  public void chargeForPhone() {
    // 家庭电源提供220V电压
    HomeBattery homeBattery = new HomeBattery();
    int homeVolt = homeBattery.supply();  
    
    // 使用家庭电源直接给手机充电
    USBLine usbLine = new USBLine();
    usbLine.charge(homeVolt);  // 程序运行后会抛出异常：java.lang.IllegalArgumentException: 只能接收 5V 电压
  }
}
```

这时，我们加入电源适配器：

```java
public class Adapter {
	public int convert(int homeVolt) {
    int chargeVolt = homeVolt - 215;  // 使用电阻电容等器件将电压降至5V
    return chargeVolt;
  }
}
```

加入适配器之后，使用家用电源经过适配器的电压转换再给手机充电：

```java
public class User {
	public void chargeForPhone() {
    // 家庭电源
    HomeBattery homeBattery = new HomeBattery();
    int homeVolt = homeBattery.supply();
    
    // 家庭电源经过适配器进行电压转换
    Adapter adapter = new Adapter();
    int chargeVolt =  adapter.convert(homeVolt);
    
    // 使用适配器转换后的电压给手机充电
    USBLine usbLine = new USBLine();
    usbLine.charge(chargeVolt);  // 此时可以正常充电
  }
}
```

适配器模式并不推荐多⽤。因为未⾬绸缪好过亡⽺补牢，如果事先能预防接⼝不同的问题，不匹配问题就不会发⽣，只有遇到源接⼝⽆法改变时，才应该考虑使⽤适配器。⽐如现代的电源插⼝中很多已经增加了专⻔的充电接⼝，让我们不需要再使⽤适配器转换接⼝，这⼜是社会的⼀个进步。

## 2. 桥接模式

**桥接模式**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。

考虑这样一个需求：绘制矩形、圆形、三角形这三种图案。按照面向对象的理念，我们至少需要三个具体类，对应三种不同的图形。

抽象接口IShape：

```java
public interface IShape {
  public void draw();
}
```

三个具体形状类：

```java
public class Rectangle implements IShape {
	@Override
  public void draw() {
    System.out.println("绘制矩形");
  }
}
```

```java
public class Circle implements IShape {
  @Override
  public void draw() {
    System.out.println("绘制圆形");
  }
}
```

```java
public class Triangle implements IShape {
  @Override
  public void draw() {
    System.out.println("绘制三角形");
  }
}
```

接下来我们有了新的需求，每种形状都需要有四种不同的颜⾊：红、蓝、⻩、绿。

 这时我们很容易想到两种设计⽅案：

- 为了复⽤形状类，将每种形状定义为⽗类，每种不同颜⾊的图形继承⾃其形状⽗类。此时⼀共有 12 个类。 为了复⽤颜⾊类，将每种颜⾊定义为⽗类，每种不同颜⾊的图形继承⾃其颜⾊⽗类。此时⼀共有 12 个类。 乍⼀看没什么问题，我们使⽤了⾯向对象的继承特性，复⽤了⽗类的代码并扩展了新的功能。 但仔细想⼀想，如果以后要增加⼀种颜⾊，⽐如⿊⾊，那么我们就需要增加三个类；如果再要增加⼀种形状，我们⼜需要增加五个类，对应 5 种颜⾊。 更不⽤说遇到增加 20 个形状，20 种颜⾊的需求，不同的排列组合将会使⼯作量变得⽆⽐的庞⼤。看来我们不得不重新思考设计⽅案。 形状和颜⾊，都是图形的两个属性。他们两者的关系是平等的，所以不属于继承关系。

- 更好的的实现⽅式 是：**将形状和颜⾊分离，根据需要对形状和颜⾊进⾏组合**，这就是桥接模式的思想。

如果⼀个对象有两种或者多种分类⽅式，并且两种分类⽅式都容易变化，⽐如本例中的形状和颜⾊。这时使⽤继承很容易造成⼦类越来越多，所以更好的做法是把这种分类⽅式分离出来，让他们独⽴变化，使⽤时将不同的分类进⾏组合即可。

使用桥接模式实现上述需求：

IColor接口类，仅包含一个获取颜色的方法：

```java
public interface IColor {
	public String getColor();
}
```

每种颜色都实现该接口：

```java
public class Red implements IColor {
  @Override 
  public String getColor() {
    return "红色";
  }
}
```

```java
public class Blue implements IColor {
  @Override
  public String getColor() {
    return "蓝色";
  }
}
```

```java
public class Yellow implements IColor {
  @Override
  public String getColor() {
    return "黄色";
  }
}
```

```java
public class Green implements IColor {
  @Override
  public String getColor() {
    return "绿色";
  }
}
```

在每个形状类中，桥接IColor接口：

```java
public class Rectangle implements IShape {
  
  private IColor color;
  
  public void setColor(IColor color) {
    this.color = color;
  }
  
  @Override
  public void draw() {
    System.out.println("绘制" + color.getColor() + "矩形");
  }
}
```

```java
public class Circle implements IShape {
  
  private IColor color;
  
  public void setColor(IColor color) {
    this.color = color;
  }
  
  @Override 
  public void draw() {
    System.out.println("绘制" + color.getColor() + "圆形");
  }
}
```

```java
public class Triangle implements IShape {
  
  private IColor color;
  
  public void setColor(IColor color) {
    this.color = color;
  }
  
  @Override
  public void draw() {
    System.out.println("绘制" + color.getColor() + "三角形");
  }
}
```

调用者：

```java
public class User {
  public void drawShape() {
  	// 绘制矩形
    Rectangle rectangle = new Rectangle();
    rectangle.setColor(new Red());  // 这里可以使用 红 蓝 黄 绿
    rectangle.draw();
    
  	// 绘制圆形
    Circle circle = new Circle();
    circle.setColor(new Blue());  // 这里可以使用 红 蓝 黄 绿
    circle.draw();
    
  	// 绘制三角形
    Triangle triangle = new Triangle();
    triangle.setColor(new Yellow());  // 这里可以使用 红 蓝 黄 绿
    triangle.draw();
  }
}
```

这时我们再来回顾⼀下官⽅定义：将抽象部分与它的实现部分分离，使它们都可以独⽴地变化。抽象部分指的是⽗类，对应本例中的形状类，实现部分指的是不同⼦类的区别之处。将⼦类的区别⽅式 —— 也就是本例中的颜⾊ —— 分离成接⼝，通过组合的⽅式桥接颜⾊和形状，这就是桥接模式，它**主要⽤于两个或多个同等级的接⼝**。

## 3. 组合模式

**组合模式**：⼜叫部分整体模式，是⽤于把⼀组相似的对象当作⼀个单⼀的对象。组合模式依据树形结构来组合对象， ⽤来表示部分以及整体层次。

组合模式用于整体与部分的结构，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。例如：

- 文件夹和子文件夹的关系：文件夹中可以存放文件，也可以新建文件夹，子文件夹也一样。

- 总公司和子公司的关系：总公司可以设立部门，也可以设立分公司，子公司也一样。

- 树枝和分树枝的关系：树枝可以长出叶子，也可以长出树枝，分树枝也一样。

考虑这样一个实际应用：设计一个公司的人员分布结构，结构如下图所示：

![preview](https://pic2.zhimg.com/v2-996bb76203be586161b57280d252c64e_r.jpg?source=1940ef5c)

我们注意到⼈员结构中有两种结构，⼀是管理者，如⽼板，PM，CFO，CTO，⼆是职员。其中有的管理者不仅仅要管理职员，还会管理其他的管理者。这就是⼀个典型的整体与部分的结构。

### 3.1 不使用组合模式的设计方案

要描述这样的结构，我们很容易想到以下设计方案：

新建管理者类：

```java
public class Manager {
	// 职位
  private String position;
  // 工作内容
  private String job;
  // 管理的管理者
  private List<Manager> managers = new ArrayList<>();
  // 管理的职员
  private List<Employee> employees = new ArrayList<>();
  
	public Manager(String position, String job) {
    this.position = position;
    this.job = job;
  }
  
  public void addManager(Manager manager) {
    managers.add(manager);
  }
  
  public void removeManager(Manager manager) {
		managers.remove(manager);
  }
  
  public void addEmployee(Employee employee) {
    employees.add(employee);
  }
  
  public void removeEmployee(Employee employee) {
    employees.remove(employee);
  }
  
  // 做自己的本职工作
  public void work() {
    System.out.println("我的职位是：" + this.position + "，我的工作内容是：" + this.job);
  }
  
  // 检查下属（下属有管理者和职员）
  public void check() {
    work();
    for (Employee employee : employees) {
      employee.work();
    }
    for (Managers manager : managers) {
      manager.check();
    }
  }
}
```

新建职员类：

```java
public class Employee {
  // 职位
  private String position;
  // 工作内容
  private String job;
  
  public Employee(String position, String job) {
    this.position = position;
    this.job = job;
  }
  
  // 做自己的本职工作
  public void work() {
    System.out.println("我的职位是：" + this.position + "，我的工作内容是：" + this.job);
  }
}
```

调用者：

```java
public class User {
  public void test() {
    Manager boss = new Manager("老板", "开公司");
    Employee HR = new Employee("人力资源", "聊天");
    Manager PM = new Manager("项目经理", "统筹项目");
    Manager CFO = new Manager("财务总监", "管钱");
    Employee UI = new Employee("UI设计", "画画");
    Manager CTO= new Manager("技术总监", "做PPT");
    Employee operator = new Employee("运营", "兼职客服");
    Employee accountant = new Employee("会计", "数钱");
    Employee clerk = new Employee("文员", "写文档");
    Employee webCoder = new Employee("前端程序员", "写前端");
    Employee backgroundCoder = new Employee("后端程序员", "写后台");
    
    boss.addEmployee(HR);
    boss.addManager(PM);
    boss.addManager(CFO);
    
    PM.addEmployee(UI);
    PM.addManager(CTO);
    PM.addEmployee(operator);
    
    CFO.addEmployee(accountant);
    CFO.addEmployee(clerk);
    
    CTO.addEmployee(webCoder);
    CTO.addEmployee(backgroundCoder);
    
    boss.check();
  }
}
```



这样我们就设计出了公司的结构，但是这样的设计有两个弊端：

- position 字段，job 字段，work()⽅法重复了
-  管理者对其管理的管理者和职员需要区别对待

关于第⼀个弊端，虽然这⾥为了讲解，只有两个字段和⼀个⽅法重复，实际⼯作中这样的整体部分结构会 有相当多的重复。⽐如此例中还可能有⼯号、年龄等字段，领取⼯资、上下班打卡、开各种⽆聊的会等⽅法。 ⼤量的重复显然是很丑陋的代码，分析⼀下可以发现， Manager 类只⽐ Employee 类多⼀个管理⼈员的列表字段，多⼏个增加 / 移除⼈员的⽅法，其他的字段和⽅法全都是⼀样的。 有读者应该会想到：我们可以将重复的字段和⽅法提取到⼀个⼯具类中，让 Employee 和 Manager 都去调⽤此⼯具类，就可以消除重复了。 这样固然可⾏，但属于 Employee 和 Manager 类⾃⼰的东⻄却要通过其他类调⽤，并不利于程序的⾼内聚。 

关于第⼆个弊端，此⽅案⽆法解决，此⽅案中 Employee 和 Manager 类完全是两个不同的对象，两者的相似性被忽略了。 所以我们有更好的设计⽅案，那就是组合模式！

### 3.2 使用组合模式的设计方案

组合模式最主要的功能就是让⽤户可以⼀致对待整体和部分结构，将两者都作为⼀个相同的组件，所以我们先新建⼀个抽象的组件类：

抽象的组件类：

```java
public abstract class Component {
  // 职位
  private String position;
  // 工作内容
  private String job;
  
  public Component(String position, String job) {
    this.position = position;
    this.job = job;
  }
  
  // 做自己的本职工作
  public void work() {
    System.out.println("我的职位是：" + this.position + "，我的工作内容是：" + this.job);
  }
  
  abstract void addComponent(Component component);
  
  abstract void removeComponent(Component component);
  
  abstract void check();
}
```

管理者继承自此抽象类：

```java
public class Manager extends Component {
  // 管理的组件
  private List<Component> components = new ArrayList<>();
  
  public Manager(String position, String job) {
    super(position, job);
  }
  
  @Override
  public void addComponent(Component component) {
    components.add(component);
  }
  
  @Override
  public void removeComponent(Component component) {
    components.remove(component);
  }
  
  @Override
  public void check() {
    work();
    for (Component component : components) {
      component.check();
    }
  }
}
```

职员同样继承自该抽象类：

```java
public class Employee extends Component{
  public Employee(String position, String job) {
    super(position, job);
  }
  
  @Override
  public void addComponent(Component component) {
    System.out.println("职员没有管理权限");
  }
  
  @Override
  public void removeComponent(Component component) {
    System.out.println("职员没有管理权限");
  }
  
  @Override
  public void check() {
    work();
  }
}
```

调用者：

```java
public class User {
	public void test() {
        // 创建
        Component boss = new Manager("老板", "job");

        Component HR = new Employee("人力资源", "job");
        Component PM = new Manager("项目经历", "job");
        Component CFO = new Manager("财务总监", "job");

        Component UI = new Employee("UI设计师", "job");
        Component CTO = new Manager("技术总监", "job");
        Component operator = new Employee("运营", "job");
        Component accountant = new Employee("会计", "job");
        Component clerk = new Employee("文员", "job");

        Component webCoder = new Employee("前端程序员", "job");
        Component backgroundCoder = new Employee("后端程序员", "");
        
        // 构建关系
        boss.addComponent(HR);
        boss.addComponent(PM);
        boss.addComponent(CFO);

        PM.addComponent(UI);
        PM.addComponent(CTO);
        PM.addComponent(operator);

        CFO.addComponent(accountant);
        CFO.addComponent(clerk);

        CTO.addComponent(webCoder);
        CTO.addComponent(backgroundCoder);
        
        // check工作
        boss.check();
  }
}
```

可以看到，使⽤组合模式后，我们解决了之前的两个弊端。

⼀是将共有的字段与⽅法移到了⽗类中，消除了重复，二是在客户端中，可以⼀致对待 Manager 和 Employee 类： 

- Manager 类和 Employee 类统⼀声明为 Component 对象
-  统⼀调⽤ Component 对象的 addComponent ⽅法添加⼦对象即可

### 3.3 组合模式中的安全方式和透明方式

Employee 类虽然继承了⽗类的 addComponent 和 removeComponent ⽅法，但是仅仅提供了⼀个空实现，因为 Employee 类是不⽀持添加和移除组件的。这样是否违背了接⼝隔离原则呢？

*接⼝隔离原则：客户端不应依赖它不需要的接⼝。如果⼀个接⼝在实现时，部分⽅法由于冗余被客户端空实现，则应该将接⼝拆分，让实现类只需依赖⾃⼰需要的接⼝⽅法。*

答案是肯定的，这样确实违背了接⼝隔离原则。这种⽅式在组合模式中被称作**透明⽅式(3.2中的实现)**。

*透明⽅式：在 Component 中声明所有管理⼦对象的⽅法，包括 add 、remove 等，这样继承⾃ Component 的⼦类都具备了 add、remove ⽅法。对于外界来说叶节点和枝节点是透明的，它们具备完全⼀致的接⼝。*

这种⽅式有它的优点：让 Manager 类和 Employee 类具备完全⼀致的⾏为接⼝，调⽤者可以⼀致对待它们。 

但它的缺点也显⽽易⻅：Employee 类并不⽀持管理⼦对象，不仅违背了接⼝隔离原则，⽽且客户端可以⽤ Employee 类调⽤ addComponent 和 removeComponent ⽅法，导致程序出错，所以这种⽅式是不安全的。 那么我们可不可以将 addComponent 和 removeComponent ⽅法移到 Manager ⼦类中去单独实现，让 Employee 不再实现这两个⽅法呢？我们来尝试⼀下。

将抽象类修改为：

*我们在⽗类中去掉了 addComponent 和 removeComponent 这两个抽象⽅法*。

```java
public abstract class Component {
  // 职位
  public String position;
  // 工作内容
  public String job;
  
  public Component(String position, String job) {
    this.position = position;
    this.job = job;
  }
  
  // 做自己的本职工作
  public void work() {
    System.out.println("我的职位是：" + this.position + "，我的工作内容是：" + this.job);
  }
  
  abstract void check();
}
```

Manager类修改为：

*Manager 类单独实现了 addComponent 和 removeComponent 这两个⽅法，去掉了 @Override 注解*。

```java
public class Manager extends Component{
  
  // 管理的组件
  private List<Component> components = new ArrayList<>();
  
  public Manager(String position, String job) {
    super(position, job);
  }
  
  public void addComponent(Component component) {
    components.add(component);
  }
  
  public void removeComponent(Component component) {
    components.remove(component);
  }
  
  // check下属
  @Override
  public void check() {
    work();
    for (Component component : components) {
      component.check();
    }
  }
}
```

Employee类修改为：

```java
public class Employee extends Conponent{
  
  public Employee(String position, String job) {
    super(position, job);
  }
  
  @Override 
  public void check() {
    work();
  }
}
```

调用者修改为：

```java
public class User {
  public void test() {
    // 创建角色
    Manager boss = new Manager("", "");
    
    Employee HR = new Employee("", "");
    Manager PM = new Manager("", "");
    Manager CFO = new Manager("", "");
    
    Employee UI = new Employee("", "");
    Manager CTO = new Manager("", "");
    Employee operator = new Employee("", "");
    Employee accountant = new Employee("", "");
    Employee clerk = new Employee("", "");
    
    Component webCoder = new Employee("", "");
    Component backgroundCoder = new Employee("", "");
    
    // 创建角色之间的关系
    boss.addComponent(HR);
    boss.addComponent(PM);
    boss.addComponent(CFO);
    
    PM.addComponent(UI);
    PM.addComponent(CTO);
    PM.addComponent(operator);
    
    CFO.addComponent(accountant);
    CFO.addComponent(clerk);
    
    CTO.addComponent(webCoder);
    CTO.addComponent(backgroundCoder);
   
 	  boss.check();
  }
}
```

这种⽅式在组合模式中称之为**安全⽅式(3.3中的实现)**。 

*安全⽅式：在 Component 中不声明 add 和 remove 等管理⼦对象的⽅法，这样叶节点就⽆需实 现它，只需在枝节点中实现管理⼦对象的⽅法即可。*

 安全⽅式遵循了接⼝隔离原则，但由于不够透明，Manager 和 Employee 类不具有相同的接⼝，在客户端中，我们⽆法将 Manager 和 Employee 统⼀声明为 Component 类了，必须要区别对待， 带来了使⽤上的不⽅便。 安全⽅式和透明⽅式各有好处，在使⽤组合模式时，需要根据实际情况决定。但⼤多数使⽤组合模 式的场景都是采⽤的透明⽅式，虽然它有点不安全，但是客户端⽆需做任何判断来区分是叶⼦结点 还是枝节点，⽤起来是真⾹

## 4. 装饰模式

装饰模式：

- 增强⼀个类原有的功能

- 为⼀个类添加新的功能

- 装饰模式也不会改变原有的类

**装饰模式**：动态地给⼀个对象增加⼀些额外的职责，就增加对象功能来说，装饰模式⽐⽣成⼦类实现更为灵活。其别名也可以称为包装器，与适配器模式的别名相同，但它们适⽤于不同的场合。根据翻译的不同，装饰模式也有⼈称之为“油漆⼯模式”

### 4.1 用于增强功能的装饰模式

我们⽤程序来模拟⼀下戴上装饰品提⾼我们颜值的过程：

新建颜值接口：

```java
public interface IBeauty {
  int getBeautyValue();
}
```

新建Me类，实现颜值接口：

```java
public class Me implements IBeauty {
  
  @Override
  public int getBeautyValue() {
    return 100;
  }
}
```

新建戒指装饰类，将Me包装起来：

```java
public class RingDecorator implements IBeauty {
  
  private final IBeauty me;
  
  public RingDecorator(IBeauty me) {
    this.me = me;
  }
  
  @Override
  public int getBeautyValue() {
    return me.getBeautyValue() + 20;
  }
}
```

调用者测试：

```java
public class User {
  public void test() {
    IBeauty me = new Me();
    System.out.println("我原本颜值为：" + me.getBeautyValue());
    
    IBeauty meWithRing = new RingDecorator(me);
    System.out.println("戴上戒指后，我的颜值为" + meWithRing.getBeautyValue());
  }
}
```

这就是最简单的增强功能的装饰模式。以后我们可以添加更多的装饰类，⽐如：

耳环装饰类：

```java
public class EarringDecorator implements IBeauty {
  
  private final IBeauty me;
  
  public EarringDecorator(IBeauty me) {
    this.me = me;
  }
  
  @Override
  public int getBeautyValue() {
    return me.getBeautyValue() + 50;
  }
}
```

项链装饰类：

```java
public class NecklaceDecorator implements IBeauty {
  
  private final IBeauty me;
  
  public NecklaceDecorator(IBeauty me) {
    this.me = me;
  }
  
  @Override
  public int getBeautyValue() {
    return me.getBeautyValue() + 60;
  }
}
```

客户端测试：

```java
public class User {
  public void test() {
    IBeauty me = new Me();
    System.out.println("我原本颜值为：" + me.getBeautyValue());
    
    // 戴上项链
    IBeauty meWithNecklace = new NecklaceDecorator(me);
    System.out.println("戴上项链后，我的颜值为" + meWithNecklace.getBeautyValue());
    
    // 多次装饰
    IBeauty meWithManyDecorators = new NecklaceDecorator(new EarringDecorator(new RingDecorator(me)));
    System.out.println("戴上项链、耳环、戒指后，我的颜值为" + meWithNecklace.getBeautyValue());
  }
}
```

可以看到，装饰器也实现了 IBeauty 接⼝，并且没有添加新的⽅法，也就是说这⾥的装饰器仅⽤于增强功能，并不会改变 Me 原有的功能，这种装饰模式称之为**透明装饰模式**，由于没有改变接⼝，也没有新增⽅法，所以**透明装饰模式可以⽆限装饰**。 

装饰模式是**继承**的⼀种替代⽅案。本例如果不使⽤装饰模式，⽽是改⽤继承实现的话，戴着戒指的 Me 需要派⽣⼀个⼦类、戴着项链的 Me 需要派⽣⼀个⼦类、戴着⽿环的 Me 需要派⽣⼀个⼦类、戴着戒指 + 项链 的需要派⽣⼀个⼦类......各种各样的排列组合会造成类爆炸。⽽采⽤了装饰模式就只需要为每个装饰品⽣成 ⼀个装饰类即可，所以说就 增加对象功能 来说，装饰模式⽐⽣成⼦类实现更为灵活。

### 4.2 用于添加功能的装饰模式

我们用程序来模拟一下房屋装饰粘钩后，新增了 挂东西 功能的过程：

新建房屋接口：

```java
public interface IHouse() {
  void live();
}
```

房屋类：

```java
public class House implements IHouse {
  
  @Override
  public void live() {
    System.out.println("房屋原有的功能：居住功能");
  }
}
```

新建粘钩房屋装饰器接口，继承自房屋接口：

```java
public interface IHookHouse extends IHouse {
  void hangThings();
}
```

粘钩装饰类：

```java
public class HookHouseDecorator implements IHook {
  
  private final IHouse house;
  
  public HookDecorator(IHouse house) {
    this.house = house;
  }
  
  @Override
  public void live() {
    house.live();
  }
  
  @Override
  public void hangThings() {
    System.out.println("有了粘钩后，新增了挂东西的功能");
  }
}
```

客户端测试：

```java
public class User {
  public void test() {
    IHouse house = new House();
    house.live();
    
    IHookHouse houseWithHook = new HookHouseDecorator(house);
    houseWithHook.live();
    houseWithHook.hangThings();
    
  }
}
```

这就是⽤于**新增功能**的装饰模式。我们在接⼝中新增了⽅法：hangThings()，然后在装饰器中将 House 类包装起来，之前 House 中的⽅法仍然调⽤ house 去执⾏，也就是说我们**并没有修改原有的功能**，只是**扩展了新的功能**，这种模式在装饰模式中称之为**半透明装饰模式**。 

为什么叫半透明呢？由于新的接⼝ IHookHouse 拥有之前 IHouse 不具有的⽅法，所以我们如果要使 ⽤装饰器中添加的功能，就不得不**区别对待 装饰前的对象和装饰后的对象**。也就是说客户端要使⽤新⽅ 法，必须知道具体的装饰类 HookHouseDecorator，所以这个装饰类对客户端来说是可⻅的、不透明的。⽽ 被装饰者不⼀定要是 House，它可以是实现了 IHouse 接⼝的任意对象，所以被装饰者对客户端是不可⻅ 的、透明的。由于⼀半透明，⼀半不透明，所以称之为半透明装饰模式。

我们可以添加更多的装饰器：

新建镜子房屋装饰器的接口，继承自房屋接口：

```java
public interface IMirrorHouse implements IHouse {
  void lookMirror();
}
```

镜子装饰器类：

```java
public class MirrorHouseDecorator implements IMirrorHouse {
  
  private finale IHouse house;
  
  public MirrorHouseDecorator(IHouse house) {
    this.house = house;
  }
  
	@Override
  public void live() {
    house.live();
  }
  
  @Override
  public void lookMirror() {
    System.out.println("有了镜子后，新增了照镜子的功能");
  }
}
```

客户端测试：

```java
public class User {
  public void test() {
    IHouse house = new House();
    house.live();
    
    IMirrorHouse houseWithMirror = new MirrorHouseDecorator(house);
    houseWithMirror.live();
    houseWithMirror.lookMirror();
  }
}
```

现在，我们仿照**透明装饰模式**的写法，同时添加粘钩装饰和镜子装饰试一试：

```java
public class User {
  public void test() {
    IHouse house = new House();
    house.live();
    
    IHookHouse houseWithHook = new HookHouseDecorator(house);
    IMirrorHouse houseWithHookAndMirror = new MirrorHouseDecorator(houseWithHook);
    houseWithHookAndMirror.live();
    houseWithHookAndMirror.hangThings();  // 这里会报错，找不到hangThings()方法
    houseWithHookAndMirror.lookMirror();
  }
}
```

我们会发现，第⼆次装饰时，⽆法获得上⼀次装饰添加的⽅法。原因很明显，当我们⽤ IMirrorHouse 装饰器后，接⼝变为了 IMirrorHouse，这个接⼝中并没有 hangThings ⽅法。

那么我们能否让 IMirrorHouse 继承⾃ IStickyHookHouse，以实现新增两个功能呢？ 可以，**但那样做的话两个装饰类之间有了依赖关系，那就不是装饰模式了**。

**装饰类不应该存在依赖关系， ⽽应该在原本的类上进⾏装饰**。这就意味着，**半透明装饰模式中，我们⽆法多次装饰**。 

有的同学会问了，既增强了功能，⼜添加了新功能的装饰模式叫什么呢？ —— 举⼀反三，肯定是叫全不透明装饰模式！ —— 并不是！**只要添加了新功能的装饰模式都称之为 半透明装饰模式**，**他们都具有不可以多次装饰的特点**。仔细理解上⽂半透明名称的由来就知道了，**“透明”指的是我们⽆需知道被装饰者具体的类**，既增强了功能，⼜添加了新功能的装饰模式仍然具有半透明特性。 看了这两个简单的例⼦，是不是发现装饰模式很简单呢？恭喜你学会了 1 + 1 = 2，现在你已经掌握了算数 的基本思想，接下来我们来做⼀道微积分题练习⼀下。

## 5. 外观模式

外观模式⾮常简单，体现的就是 Java 中封装的思想。将多个⼦系统封装起来，提供⼀个更简洁的接⼝供外部调⽤。

![preview](https://pic4.zhimg.com/v2-c75e41044733a59739f416b2100e21b7_r.jpg?source=1940ef5c)

**外观模式**：外部与⼀个⼦系统的通信必须通过⼀个统⼀的外观对象进⾏，为⼦系统中的⼀组接⼝提供⼀个 ⼀致的界⾯，外观模式定义了⼀个⾼层接⼝，这个接⼝使得这⼀⼦系统更加容易使⽤。外观模式⼜称为⻔⾯模式

举个例子，比如我们每天打开电脑时，都需要做三件事：

- 打开浏览器

- 打开IDE

- 打开微信

每天下班前，需要做三件事：

- 关闭浏览器
- 关闭IDE
- 关闭微信

用程序模拟如下：

新建浏览器类：

```java
public class Browser {
  public static void open() {
    System.out.println("打开浏览器");
  }
  
  public static void close() {
    System.out.println("关闭浏览器");
  }
}
```

新建IDE类：

```java
public class IDE {
  public static void open() {
    System.out.println("打开IDE");
  }
  
  public static void close() {
    System.out.println("关闭IDE");
  }
}
```

新建微信类：

```java
public class Wechat {
  public static void open() {
    System.out.println("打开微信");
  }
  
  public static void open() {
    System.out.println("关闭微信");
  }
}
```

客户端调用：

```java
public class User {
  public void test() {
    System.out.println("上班：");
    Browser.open();
    IDE.open();
    Wechat.open();
    
    System.out.println("下班：");
    Browser.close();
    IDE.close();
    Wechat.close();
  }
}
```

由于我们每天都要做这⼏件事，所以我们可以使⽤外观模式，将这⼏个⼦系统封装起来，提供更简洁的接口：

```java
public class Facade {
  public void open() {
    Browser.open();
    IDE.open();
    Wechat.open();
  }
  
  public void close() {
    Browser.close();
    IDE.close();
    Wechat.close();
  }
}
```

调用者就可以简化代码，只和这个外观类打交道：

```java
public class User {
  public void test() {
    Facade facade = new Facade();
    System.out.println("上班：");
    facade.open();
    
    System.out.println("下班：");
    facade.close();
  }
}
```

外观模式就是这么简单，它使得两种不同的类不⽤直接交互，⽽是通过⼀个中间件——也就是外观类—— 间接交互。

外观类中只需要暴露简洁的接⼝，隐藏内部的细节，所以说⽩了就是封装的思想。 

外观模式⾮常常⽤，（当然了！写代码哪有不封装的！）尤其是在第三⽅库的设计中，我们应该提供尽量 简洁的接⼝供别⼈调⽤。另外，在 MVC 架构中，C 层（Controller）就可以看作是外观类，Model 和 View 层通过 Controller 交互，减少了耦合。

## 6. 享元模式

享元模式体现的是 程序可复⽤ 的特点，为了节约宝贵的内存，程序应该尽可能地复⽤，就像《极限编程》 作者 Kent 在书⾥说到的那样：Don't repeat yourself. 简单来说 享元模式就是共享对象，提⾼复⽤性，官⽅的定义倒是显得⽂绉绉的。

*享元模式：运⽤共享技术有效地⽀持⼤量细粒度对象的复⽤。系统只使⽤少量的对象，⽽这些对象都很相似，状态变化很⼩，可以实现对象的多次复⽤。由于享元模式要求能够共享的对象必须是细粒度对象，因 此它⼜称为轻量级模式*。

## 7. 代理模式

### 7.1 静态代理

现在我们有一个Person类，他整天只负责吃饭、睡觉：

Person这个类的接口：

```java
public interface IPerson {
  void eat();
  void sleep();
}
```

Person这个类：

```java
public class Person implements IPerson {
  @Override
  public void eat() {
    System.out.println("我在吃饭");
  }
  
  @Override
  public void sleep() {
    System.out.println("我在睡觉");
  }
}
```

调用者测试：

```java
public class User {
	public void test() {
    Person person = new Person();
    person.eat();
    person.sleep();
  }
}
```

我们可以把这个类包装到另⼀个类中，实现完全⼀样的⾏为：

```java
public class PersonProxy implements IPerson {
  
  private final Person person;
  
  public PersonProxy(Person person) {
    this.person = person;
  }
  
  @Override
  public void eat() {
    person.eat();
  }
  
  @Override
  public void sleep() {
    person.sleep();
  }
  
}
```

将调用者修改为调用这个代理：

```java
public class User {
  public void test() {
    Person person = new Person();
    PersonProxy proxy = new PersonProxy(person);
    proxy.eat();
    proxy.sleep();
  }
}
```

笔者尽量⽤最简洁的代码讲解此模式，只要理解了上述这个简单的例⼦，你就知道代理模式是怎么⼀回事 了。我们在客户端和 Person 类之间新增了⼀个中间件 PersonProxy，这个类就叫做代理类，他实现了和 Person 类⼀模⼀样的⾏为。

*代理模式：给某⼀个对象提供⼀个代理，并由代理对象控制对原对象的引⽤*。

现在这个代理类还看不出任何意义，我们来模拟⼀下⼯作中的需求。在实际⼯作中，我们可能会遇到这样的需求：在⽹络请求前后，分别打印将要发送的数据和接收到数据作为⽇志信息。此时我们就可以新建⼀个⽹络请求的代理类，让它代为处理⽹络请求，并在代理类中打印这些⽇志信息。 

新建⽹络请求接⼝：

```java
public interface IHttp {
	void request(String sendData);
  
  void onSuccess(String receivedData);
}
```

新建Http请求工具类：

```java
public class HttpUtil implements IHttp {
	@Override
  public void request(String sendData) {
    System.out.println("网络请求中...");
  }
  
  @Override
  public void onSuccess(String receivedData) {
    System.out.println("网络请求完成...");
  }
}
```

新建Http代理类：

同时在Http代理中新增打印日志功能：

```java
public class HttpProxy implements IHttp {
  
  private final HttpUtil httpUtil;
  
  public HttpProxy(HttpUtil httpUtil) {
    this.httpUtil = httpUtil;
  }
  
  @Override
  public void request(String sendData) {
    System.out.println("发送数据：" + sendData);
    httpUtil.request(sendData);
  }
  
  @Override
  public void onSuccess(String receivedData) {
    System.out.println("收到数据：" + receivedData);
    httpUtil.onSuccess(receivedData);
  }
  
}
```

调用者：

```java
public class User {
  public void test() {
    HttpUtil httpUtil = new HttpUtil();
    HttpProxy proxy = new HttpProxy(httpUtil);
    
    proxy.request("request data");
    proxy.onSuccess("received data");
  }
}
```

这就是代理模式的⼀个应⽤，除了打印⽇志，它还可以⽤来做权限管理。

### 7.2 动态代理

7.1例中的代理被称之为**静态代理**，**动态代理**与静态代理的原理⼀模⼀样，只是换了⼀种写法。

使⽤动态代理，需要用到反射机制。

动态代理类：

```java
public class HttpProxy implements InvocationHandler {
  
  private HttpUtil httpUtil;
  
  public IHttp getInstance(HttpUtil httpUtil) {
    this.httpUtil = httpUtil;
    return (IHttp) Proxy.newProxyInstance(httpUtil.getClass().getClassLoader(), httpUtil.getClass().getInterfaces, this);
  }
  
  // 调用httpUtil的任意方法时，都要通过这个方法调用
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Object result = null;
    if (method.getName().equals("request")) {
      // 如果⽅法名是 request，打印⽇志，并调⽤ request ⽅法
			System.out.println("发送数据:" + args[0]);
			result = method.invoke(httpUtil, args);
    } else if (method.getName().equals("onSuccess")) {
      // 如果⽅法名是 onSuccess，打印⽇志，并调⽤ onSuccess ⽅法
			System.out.println("收到数据:" + args[0]);
			result = method.invoke(httpUtil, args);
    }
    return result;
  }
}
```

先看 getInstance ⽅法，Proxy.newProxyInstance ⽅法是 Java 系统提供的⽅法，专⻔⽤于动态代理。其中传⼊的第⼀个参数是被代理的类的 ClassLoader，第⼆个参数是被代理类的 Interfaces，这两个参数都是 Object 中的，每个类都有，这⾥就是固定写法。我们只要知道系统需要这两个参数才能让我们实现我们的⽬的：调⽤被代理类的任意⽅法时，都通过⼀个⽅法间接调⽤。现在我们给系统提供了这两个参数，系统就会在第三个参数中帮我们实现这个⽬的。

第三个参数是 InvocationHandler 接⼝，这个接⼝中只有⼀个⽅法：

```
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
```

那么不⽤猜就知道，现在我们调⽤被代理类 httpUtil 的任意⽅法时，都会通过这个 invoke ⽅法调⽤了。 invoke ⽅法中，第⼀个参数我们暂时⽤不上，第⼆个参数 method 就是调⽤的⽅法，使⽤ method.getName() 可以获取到⽅法名，第三个参数是调⽤ method ⽅法需要传⼊的参数。本例中⽆论 request 还是 onSuccess 都只有⼀个 String 类型的参数，对应到这⾥就是 args[0]。返回的 Object 是 method ⽅法的返回值，本例中都是⽆返回值的。 我们在 invoke ⽅法中判断了当前调⽤⽅法的⽅法名，如果现在调⽤的⽅法是 request，那么打印请求参数， 并使⽤这⼀⾏代码继续执⾏当前⽅法。

```
result = method.invoke(httpUtil, args);
```

这就是**反射调⽤函数**的写法，如果不了解可以记做固定写法。虽然这个函数没有返回值，但我们还是将 result 返回，这是标准做法。 如果现在调⽤的⽅法是 onSuccess，那么打印接收到的数据，并反射继续执⾏当前⽅法。 

修改调用者验证⼀下：

```java
public class User {
  public void test() {
    HttpUtil httpUtil = new HttpUtil();
    IHttp proxy = new HttpProxy().getInstance(httpUtil);
    proxy.request("request data");
    proxy.onSuccess("received result");
  }
}
```

动态代理本质上与静态代理没有区别，它的好处是节省代码量。⽐如被代理类有 20 个⽅法，⽽我们只需要 控制其中的两个⽅法，就可以⽤动态代理通过⽅法名对被代理类进⾏动态的控制，⽽如果⽤静态⽅法，我 们就需要将另外的 18 个⽅法也写出来，⾮常繁琐。这就是动态代理的优势所在。