# 目录

[TOC]

# 内容

### 1. TCP协议的三次握手和四次挥手（描述TCP连接和释放的过程）

#### 1.1 三次握手和四次挥手的过程

**（1）TCP的三次握手**

「三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。在socket编程中，客户端执行connect()时，将触发三次握手。」

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。下面进行三次握手：

* 第一次握手

  客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(C)。此时客户端处于 SYN_SEND 状态。

  首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

- 第二次握手

  服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。

  在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。

- 第三次握手

  客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

  确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

  发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。

  ![preview](https://pic3.zhimg.com/v2-2a54823bd63e16674874aa46a67c6c72_r.jpg)

（2）TCP的四次挥手

「建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。」

「TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。在socket编程中，任何一方执行close()操作即可产生挥手操作。」

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

- 第一次挥手

  客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。

  即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

- 第二次挥手

  服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。

  即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

- 第三次挥手

  如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

  即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

- 第四次挥手

  客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

  即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

  收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

  ![preview](https://pic2.zhimg.com/v2-c7d4b5aca66560365593f57385ce9fa9_r.jpg)

#### 1.2 TCP为什么要建立连接？

保证可靠传输。

#### 1.3 TCP为什么需要三次握手，两次不行吗？

要弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

- 第一次握手：客户端发送网络包，服务端收到了。

  这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

- 第二次握手：服务端发送网络包，客户端收到了。

  这样客户端就能得出结论：客户端的发送、接收能力，服务端的接收、发送能力，是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

- 第三次握手：客户端发包，服务端收到了。

  这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

三次握手后，客户端和服务端都可以最终得出结论：客户端的发送、接收能力正常，服务端的发送、接收能力正常。因此，需要三次握手才能确认双方的接收与发送能力是否正常。

**ps：**如果只用两次握手，可能会出现下列情况：

*如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。*

#### 1.4 什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

这里在补充一点关于SYN-ACK 重传次数的问题：

服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

#### 1.5 ISN是固定的吗？

#### 1.6 解释为什么TCP可靠一些？

#### 1.7 三次握手过程中可以携带数据吗？

#### 1.8 SYN攻击是什么？

#### 1.9 挥手为什么需要四次？

#### 1.10 2ML等待状态是什么？

#### 1.11 TIME_WAIT状态有什么用？为什么持续2MSL？

#### 1.12 四次挥手释放连接时，等待2MSL的意义?

#### 1.13 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

#### 1.14 说明哪种应用场景会使用TCP协议？使用它的意义是什么？

---

### 2. 解释一下，HTTP请求中的304状态码的含义

### 3. 说明一下，SSL四次握手的过程

### 4. HTTP1.1和1.0的区别

### 5. 请谈一下，你知道的HTTP请求，并说明应答码502和504的区别

### 6请说明一下HTTP和HTTPS的区别

### 7. 请讲一下在浏览器中输入一个URL，到最后展示出页面，经历了哪些过程

### 8. TCP协议、IP协议和HTTP协议分别在哪一层？

### 9. 请简单解释一下，arp协议和arp攻击

### 10. 什么是icmp协议，它的作用是什么

### 11. 请你讲一下路由器和交换机的区别

### 12. 请你谈谈DNS的寻址过程

### 13. 请你讲一下，负载均衡 反向代理模式的优点和缺点