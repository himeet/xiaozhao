# 目录

[TOC]

# 内容

### 1. 谈谈64位操作系统和32位操作系统的区别

操作系统只是硬件和应用软件中间的一个平台。32位操作系统针对32位的CPU设计，64位操作系统针对64位CPU设计。

### 2. 谈谈CentOS和Linux的关系

CentOS是Linux众多的发行版本之一。

### 3. 解释一下，Linux下的线程，GDI类



### 4. 进程和线程的区别是什么？

进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。

下面是一个生动的例子：

转载于[https://www.zhihu.com/question/25532384/answer/411179772]

做个简单的比喻：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

### 5. 谈一谈，系统线程数量上限是什么？

Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。

这个限制可以在/usr/include/bits/local_lim.h中查看 ，对 linuxthreads 这个值一般是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。

这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程栈大小，一般情况下，这个值是8M=8192KB。

### 6. 请问，如何杀死一个进程？

```
kill 进程号
kill -9 进程号  // -9表示强制执行
```

### 7. 请介绍一下，socket编程的三种通信模型，BIO，NIO和AIO

https://blog.csdn.net/weixin_43809223/article/details/100529810

### 8. 你怎么理解操作系统里的内存碎片，有什么解决办法？

内存碎片分为：内部碎片和外部碎片。

内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；

内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。

单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。

外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。

外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。

### 9. 介绍一下，什么是页式存储？

主存被等分成大小相等的片，称为主存块，又称为实页。

当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为2^n ,通常为1KB、2KB、2^n KB等

### 10. 谈一谈，系统如何提高并发性？

1、提高CPU并发计算能力

（1）多进程&多线程

（2）减少进程切换，使用线程，考虑进程绑定CPU

（3）减少使用不必要的锁，考虑无锁编程

（4）考虑进程优先级

（5）关注系统负载

2、改进I/O模型

(1)DMA技术

(2)异步I/O

(3)改进多路I/O就绪通知策略，epoll

(4)Sendfile

(5)内存映射

(6)直接I/O

### 11. 请你解释一下，通常系统CPU比较高是什么原因？

### 12. 死锁（参考《2020王道操作系统》P122）

#### 12.1 死锁的定义

多个进程因**竞争资源**而造成的一种僵局（互相等待），若无外力作用，这些进程都无法向前推进。

#### 12.2 什么情况下会发生死锁/死锁产生的原因

（1）系统资源的竞争

系统中拥有的**不可剥夺资源**，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。（只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的）

（2）进程推进顺序非法

进程在运行过程中，请求和释放资源的顺序不当，也同样会引起死锁。

信号量使用不当也会造成死锁。

（3）死锁产生的必要条件

产生死锁必须同时满足以下4个条件，只要其中任意一个条件不成立，死锁就不会发生。

- 互斥条件

  进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

- 不剥夺条件

  进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来主动释放。

- 请求并保持条件

  进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

- 循环等待条件

  存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

#### 12.3 解决死锁的策略

### 13. 